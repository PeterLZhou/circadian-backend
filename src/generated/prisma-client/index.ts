// Code generated by Prisma (prisma@1.22.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  calorieData: (where?: CalorieDataWhereInput) => Promise<boolean>;
  calorieLog: (where?: CalorieLogWhereInput) => Promise<boolean>;
  distanceData: (where?: DistanceDataWhereInput) => Promise<boolean>;
  distanceLog: (where?: DistanceLogWhereInput) => Promise<boolean>;
  fitbitAccount: (where?: FitbitAccountWhereInput) => Promise<boolean>;
  googleFitAccount: (where?: GoogleFitAccountWhereInput) => Promise<boolean>;
  heartData: (where?: HeartDataWhereInput) => Promise<boolean>;
  heartLog: (where?: HeartLogWhereInput) => Promise<boolean>;
  sleepData: (where?: SleepDataWhereInput) => Promise<boolean>;
  sleepLog: (where?: SleepLogWhereInput) => Promise<boolean>;
  stepData: (where?: StepDataWhereInput) => Promise<boolean>;
  stepLog: (where?: StepLogWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  calorieData: (where: CalorieDataWhereUniqueInput) => CalorieDataPromise;
  calorieDatas: (
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CalorieData>;
  calorieDatasConnection: (
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CalorieDataConnectionPromise;
  calorieLog: (where: CalorieLogWhereUniqueInput) => CalorieLogPromise;
  calorieLogs: (
    args?: {
      where?: CalorieLogWhereInput;
      orderBy?: CalorieLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CalorieLog>;
  calorieLogsConnection: (
    args?: {
      where?: CalorieLogWhereInput;
      orderBy?: CalorieLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CalorieLogConnectionPromise;
  distanceData: (where: DistanceDataWhereUniqueInput) => DistanceDataPromise;
  distanceDatas: (
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DistanceData>;
  distanceDatasConnection: (
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DistanceDataConnectionPromise;
  distanceLog: (where: DistanceLogWhereUniqueInput) => DistanceLogPromise;
  distanceLogs: (
    args?: {
      where?: DistanceLogWhereInput;
      orderBy?: DistanceLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DistanceLog>;
  distanceLogsConnection: (
    args?: {
      where?: DistanceLogWhereInput;
      orderBy?: DistanceLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DistanceLogConnectionPromise;
  fitbitAccount: (where: FitbitAccountWhereUniqueInput) => FitbitAccountPromise;
  fitbitAccounts: (
    args?: {
      where?: FitbitAccountWhereInput;
      orderBy?: FitbitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FitbitAccount>;
  fitbitAccountsConnection: (
    args?: {
      where?: FitbitAccountWhereInput;
      orderBy?: FitbitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FitbitAccountConnectionPromise;
  googleFitAccount: (
    where: GoogleFitAccountWhereUniqueInput
  ) => GoogleFitAccountPromise;
  googleFitAccounts: (
    args?: {
      where?: GoogleFitAccountWhereInput;
      orderBy?: GoogleFitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GoogleFitAccount>;
  googleFitAccountsConnection: (
    args?: {
      where?: GoogleFitAccountWhereInput;
      orderBy?: GoogleFitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GoogleFitAccountConnectionPromise;
  heartData: (where: HeartDataWhereUniqueInput) => HeartDataPromise;
  heartDatas: (
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HeartData>;
  heartDatasConnection: (
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HeartDataConnectionPromise;
  heartLog: (where: HeartLogWhereUniqueInput) => HeartLogPromise;
  heartLogs: (
    args?: {
      where?: HeartLogWhereInput;
      orderBy?: HeartLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HeartLog>;
  heartLogsConnection: (
    args?: {
      where?: HeartLogWhereInput;
      orderBy?: HeartLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HeartLogConnectionPromise;
  sleepData: (where: SleepDataWhereUniqueInput) => SleepDataPromise;
  sleepDatas: (
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SleepData>;
  sleepDatasConnection: (
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SleepDataConnectionPromise;
  sleepLog: (where: SleepLogWhereUniqueInput) => SleepLogPromise;
  sleepLogs: (
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SleepLog>;
  sleepLogsConnection: (
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SleepLogConnectionPromise;
  stepData: (where: StepDataWhereUniqueInput) => StepDataPromise;
  stepDatas: (
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<StepData>;
  stepDatasConnection: (
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StepDataConnectionPromise;
  stepLog: (where: StepLogWhereUniqueInput) => StepLogPromise;
  stepLogs: (
    args?: {
      where?: StepLogWhereInput;
      orderBy?: StepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<StepLog>;
  stepLogsConnection: (
    args?: {
      where?: StepLogWhereInput;
      orderBy?: StepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StepLogConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCalorieData: (data: CalorieDataCreateInput) => CalorieDataPromise;
  updateCalorieData: (
    args: { data: CalorieDataUpdateInput; where: CalorieDataWhereUniqueInput }
  ) => CalorieDataPromise;
  updateManyCalorieDatas: (
    args: {
      data: CalorieDataUpdateManyMutationInput;
      where?: CalorieDataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCalorieData: (
    args: {
      where: CalorieDataWhereUniqueInput;
      create: CalorieDataCreateInput;
      update: CalorieDataUpdateInput;
    }
  ) => CalorieDataPromise;
  deleteCalorieData: (where: CalorieDataWhereUniqueInput) => CalorieDataPromise;
  deleteManyCalorieDatas: (
    where?: CalorieDataWhereInput
  ) => BatchPayloadPromise;
  createCalorieLog: (data: CalorieLogCreateInput) => CalorieLogPromise;
  updateCalorieLog: (
    args: { data: CalorieLogUpdateInput; where: CalorieLogWhereUniqueInput }
  ) => CalorieLogPromise;
  updateManyCalorieLogs: (
    args: {
      data: CalorieLogUpdateManyMutationInput;
      where?: CalorieLogWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCalorieLog: (
    args: {
      where: CalorieLogWhereUniqueInput;
      create: CalorieLogCreateInput;
      update: CalorieLogUpdateInput;
    }
  ) => CalorieLogPromise;
  deleteCalorieLog: (where: CalorieLogWhereUniqueInput) => CalorieLogPromise;
  deleteManyCalorieLogs: (where?: CalorieLogWhereInput) => BatchPayloadPromise;
  createDistanceData: (data: DistanceDataCreateInput) => DistanceDataPromise;
  updateDistanceData: (
    args: { data: DistanceDataUpdateInput; where: DistanceDataWhereUniqueInput }
  ) => DistanceDataPromise;
  updateManyDistanceDatas: (
    args: {
      data: DistanceDataUpdateManyMutationInput;
      where?: DistanceDataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDistanceData: (
    args: {
      where: DistanceDataWhereUniqueInput;
      create: DistanceDataCreateInput;
      update: DistanceDataUpdateInput;
    }
  ) => DistanceDataPromise;
  deleteDistanceData: (
    where: DistanceDataWhereUniqueInput
  ) => DistanceDataPromise;
  deleteManyDistanceDatas: (
    where?: DistanceDataWhereInput
  ) => BatchPayloadPromise;
  createDistanceLog: (data: DistanceLogCreateInput) => DistanceLogPromise;
  updateDistanceLog: (
    args: { data: DistanceLogUpdateInput; where: DistanceLogWhereUniqueInput }
  ) => DistanceLogPromise;
  updateManyDistanceLogs: (
    args: {
      data: DistanceLogUpdateManyMutationInput;
      where?: DistanceLogWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDistanceLog: (
    args: {
      where: DistanceLogWhereUniqueInput;
      create: DistanceLogCreateInput;
      update: DistanceLogUpdateInput;
    }
  ) => DistanceLogPromise;
  deleteDistanceLog: (where: DistanceLogWhereUniqueInput) => DistanceLogPromise;
  deleteManyDistanceLogs: (
    where?: DistanceLogWhereInput
  ) => BatchPayloadPromise;
  createFitbitAccount: (data: FitbitAccountCreateInput) => FitbitAccountPromise;
  updateFitbitAccount: (
    args: {
      data: FitbitAccountUpdateInput;
      where: FitbitAccountWhereUniqueInput;
    }
  ) => FitbitAccountPromise;
  updateManyFitbitAccounts: (
    args: {
      data: FitbitAccountUpdateManyMutationInput;
      where?: FitbitAccountWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFitbitAccount: (
    args: {
      where: FitbitAccountWhereUniqueInput;
      create: FitbitAccountCreateInput;
      update: FitbitAccountUpdateInput;
    }
  ) => FitbitAccountPromise;
  deleteFitbitAccount: (
    where: FitbitAccountWhereUniqueInput
  ) => FitbitAccountPromise;
  deleteManyFitbitAccounts: (
    where?: FitbitAccountWhereInput
  ) => BatchPayloadPromise;
  createGoogleFitAccount: (
    data: GoogleFitAccountCreateInput
  ) => GoogleFitAccountPromise;
  updateGoogleFitAccount: (
    args: {
      data: GoogleFitAccountUpdateInput;
      where: GoogleFitAccountWhereUniqueInput;
    }
  ) => GoogleFitAccountPromise;
  updateManyGoogleFitAccounts: (
    args: {
      data: GoogleFitAccountUpdateManyMutationInput;
      where?: GoogleFitAccountWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGoogleFitAccount: (
    args: {
      where: GoogleFitAccountWhereUniqueInput;
      create: GoogleFitAccountCreateInput;
      update: GoogleFitAccountUpdateInput;
    }
  ) => GoogleFitAccountPromise;
  deleteGoogleFitAccount: (
    where: GoogleFitAccountWhereUniqueInput
  ) => GoogleFitAccountPromise;
  deleteManyGoogleFitAccounts: (
    where?: GoogleFitAccountWhereInput
  ) => BatchPayloadPromise;
  createHeartData: (data: HeartDataCreateInput) => HeartDataPromise;
  updateHeartData: (
    args: { data: HeartDataUpdateInput; where: HeartDataWhereUniqueInput }
  ) => HeartDataPromise;
  updateManyHeartDatas: (
    args: {
      data: HeartDataUpdateManyMutationInput;
      where?: HeartDataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertHeartData: (
    args: {
      where: HeartDataWhereUniqueInput;
      create: HeartDataCreateInput;
      update: HeartDataUpdateInput;
    }
  ) => HeartDataPromise;
  deleteHeartData: (where: HeartDataWhereUniqueInput) => HeartDataPromise;
  deleteManyHeartDatas: (where?: HeartDataWhereInput) => BatchPayloadPromise;
  createHeartLog: (data: HeartLogCreateInput) => HeartLogPromise;
  updateHeartLog: (
    args: { data: HeartLogUpdateInput; where: HeartLogWhereUniqueInput }
  ) => HeartLogPromise;
  updateManyHeartLogs: (
    args: { data: HeartLogUpdateManyMutationInput; where?: HeartLogWhereInput }
  ) => BatchPayloadPromise;
  upsertHeartLog: (
    args: {
      where: HeartLogWhereUniqueInput;
      create: HeartLogCreateInput;
      update: HeartLogUpdateInput;
    }
  ) => HeartLogPromise;
  deleteHeartLog: (where: HeartLogWhereUniqueInput) => HeartLogPromise;
  deleteManyHeartLogs: (where?: HeartLogWhereInput) => BatchPayloadPromise;
  createSleepData: (data: SleepDataCreateInput) => SleepDataPromise;
  updateSleepData: (
    args: { data: SleepDataUpdateInput; where: SleepDataWhereUniqueInput }
  ) => SleepDataPromise;
  updateManySleepDatas: (
    args: {
      data: SleepDataUpdateManyMutationInput;
      where?: SleepDataWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSleepData: (
    args: {
      where: SleepDataWhereUniqueInput;
      create: SleepDataCreateInput;
      update: SleepDataUpdateInput;
    }
  ) => SleepDataPromise;
  deleteSleepData: (where: SleepDataWhereUniqueInput) => SleepDataPromise;
  deleteManySleepDatas: (where?: SleepDataWhereInput) => BatchPayloadPromise;
  createSleepLog: (data: SleepLogCreateInput) => SleepLogPromise;
  updateSleepLog: (
    args: { data: SleepLogUpdateInput; where: SleepLogWhereUniqueInput }
  ) => SleepLogPromise;
  updateManySleepLogs: (
    args: { data: SleepLogUpdateManyMutationInput; where?: SleepLogWhereInput }
  ) => BatchPayloadPromise;
  upsertSleepLog: (
    args: {
      where: SleepLogWhereUniqueInput;
      create: SleepLogCreateInput;
      update: SleepLogUpdateInput;
    }
  ) => SleepLogPromise;
  deleteSleepLog: (where: SleepLogWhereUniqueInput) => SleepLogPromise;
  deleteManySleepLogs: (where?: SleepLogWhereInput) => BatchPayloadPromise;
  createStepData: (data: StepDataCreateInput) => StepDataPromise;
  updateStepData: (
    args: { data: StepDataUpdateInput; where: StepDataWhereUniqueInput }
  ) => StepDataPromise;
  updateManyStepDatas: (
    args: { data: StepDataUpdateManyMutationInput; where?: StepDataWhereInput }
  ) => BatchPayloadPromise;
  upsertStepData: (
    args: {
      where: StepDataWhereUniqueInput;
      create: StepDataCreateInput;
      update: StepDataUpdateInput;
    }
  ) => StepDataPromise;
  deleteStepData: (where: StepDataWhereUniqueInput) => StepDataPromise;
  deleteManyStepDatas: (where?: StepDataWhereInput) => BatchPayloadPromise;
  createStepLog: (data: StepLogCreateInput) => StepLogPromise;
  updateStepLog: (
    args: { data: StepLogUpdateInput; where: StepLogWhereUniqueInput }
  ) => StepLogPromise;
  updateManyStepLogs: (
    args: { data: StepLogUpdateManyMutationInput; where?: StepLogWhereInput }
  ) => BatchPayloadPromise;
  upsertStepLog: (
    args: {
      where: StepLogWhereUniqueInput;
      create: StepLogCreateInput;
      update: StepLogUpdateInput;
    }
  ) => StepLogPromise;
  deleteStepLog: (where: StepLogWhereUniqueInput) => StepLogPromise;
  deleteManyStepLogs: (where?: StepLogWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  calorieData: (
    where?: CalorieDataSubscriptionWhereInput
  ) => CalorieDataSubscriptionPayloadSubscription;
  calorieLog: (
    where?: CalorieLogSubscriptionWhereInput
  ) => CalorieLogSubscriptionPayloadSubscription;
  distanceData: (
    where?: DistanceDataSubscriptionWhereInput
  ) => DistanceDataSubscriptionPayloadSubscription;
  distanceLog: (
    where?: DistanceLogSubscriptionWhereInput
  ) => DistanceLogSubscriptionPayloadSubscription;
  fitbitAccount: (
    where?: FitbitAccountSubscriptionWhereInput
  ) => FitbitAccountSubscriptionPayloadSubscription;
  googleFitAccount: (
    where?: GoogleFitAccountSubscriptionWhereInput
  ) => GoogleFitAccountSubscriptionPayloadSubscription;
  heartData: (
    where?: HeartDataSubscriptionWhereInput
  ) => HeartDataSubscriptionPayloadSubscription;
  heartLog: (
    where?: HeartLogSubscriptionWhereInput
  ) => HeartLogSubscriptionPayloadSubscription;
  sleepData: (
    where?: SleepDataSubscriptionWhereInput
  ) => SleepDataSubscriptionPayloadSubscription;
  sleepLog: (
    where?: SleepLogSubscriptionWhereInput
  ) => SleepLogSubscriptionPayloadSubscription;
  stepData: (
    where?: StepDataSubscriptionWhereInput
  ) => StepDataSubscriptionPayloadSubscription;
  stepLog: (
    where?: StepLogSubscriptionWhereInput
  ) => StepLogSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SleepDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sleepLogId_ASC"
  | "sleepLogId_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "level_ASC"
  | "level_DESC"
  | "second_ASC"
  | "second_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CalorieLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "totalCalories_ASC"
  | "totalCalories_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HeartLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "caloriesOutOfRange_ASC"
  | "caloriesOutOfRange_DESC"
  | "minutesOutOfRange_ASC"
  | "minutesOutOfRange_DESC"
  | "maxValueOutOfRange_ASC"
  | "maxValueOutOfRange_DESC"
  | "minValueOutOfRange_ASC"
  | "minValueOutOfRange_DESC"
  | "caloriesFatBurn_ASC"
  | "caloriesFatBurn_DESC"
  | "minutesFatBurn_ASC"
  | "minutesFatBurn_DESC"
  | "maxValueFatBurn_ASC"
  | "maxValueFatBurn_DESC"
  | "minValueFatBurn_ASC"
  | "minValueFatBurn_DESC"
  | "caloriesCardio_ASC"
  | "caloriesCardio_DESC"
  | "minutesCardio_ASC"
  | "minutesCardio_DESC"
  | "maxValueCardio_ASC"
  | "maxValueCardio_DESC"
  | "minValueCardio_ASC"
  | "minValueCardio_DESC"
  | "caloriesPeak_ASC"
  | "caloriesPeak_DESC"
  | "minutesPeak_ASC"
  | "minutesPeak_DESC"
  | "maxValuePeak_ASC"
  | "maxValuePeak_DESC"
  | "minValuePeak_ASC"
  | "minValuePeak_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HeartDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "heartLogId_ASC"
  | "heartLogId_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "heartRate_ASC"
  | "heartRate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StepDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "stepLogId_ASC"
  | "stepLogId_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "steps_ASC"
  | "steps_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DistanceDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "distanceLogId_ASC"
  | "distanceLogId_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "distance_ASC"
  | "distance_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DistanceLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "totalDistance_ASC"
  | "totalDistance_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FitbitAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "fitbitUserId_ASC"
  | "fitbitUserId_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC"
  | "accessToken_ASC"
  | "accessToken_DESC"
  | "expiration_ASC"
  | "expiration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GoogleFitAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC"
  | "accessToken_ASC"
  | "accessToken_DESC"
  | "expiration_ASC"
  | "expiration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CalorieDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "calorieLogId_ASC"
  | "calorieLogId_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "calories_ASC"
  | "calories_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StepLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "totalSteps_ASC"
  | "totalSteps_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type SleepLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "dateOfSleep_ASC"
  | "dateOfSleep_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "efficiency_ASC"
  | "efficiency_DESC"
  | "isMainSleep_ASC"
  | "isMainSleep_DESC"
  | "logId_ASC"
  | "logId_DESC"
  | "minutesAfterWakeup_ASC"
  | "minutesAfterWakeup_DESC"
  | "minutesAsleep_ASC"
  | "minutesAsleep_DESC"
  | "minutesAwake_ASC"
  | "minutesAwake_DESC"
  | "minutesToFallAsleep_ASC"
  | "minutesToFallAsleep_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "timeInBed_ASC"
  | "timeInBed_DESC"
  | "type_ASC"
  | "type_DESC"
  | "summaryDeepCount_ASC"
  | "summaryDeepCount_DESC"
  | "summaryDeepMinutes_ASC"
  | "summaryDeepMinutes_DESC"
  | "summaryDeepThirtyDayAvgMinutes_ASC"
  | "summaryDeepThirtyDayAvgMinutes_DESC"
  | "summaryLightCount_ASC"
  | "summaryLightCount_DESC"
  | "summaryLightMinutes_ASC"
  | "summaryLightMinutes_DESC"
  | "summaryLightThirtyDayAvgMinutes_ASC"
  | "summaryLightThirtyDayAvgMinutes_DESC"
  | "summaryRemCount_ASC"
  | "summaryRemCount_DESC"
  | "summaryRemMinutes_ASC"
  | "summaryRemMinutes_DESC"
  | "summaryRemThirtyDayAvgMinutes_ASC"
  | "summaryRemThirtyDayAvgMinutes_DESC"
  | "summaryWakeCount_ASC"
  | "summaryWakeCount_DESC"
  | "summaryWakeMinutes_ASC"
  | "summaryWakeMinutes_DESC"
  | "summaryWakeThirtyDayAvgMinutes_ASC"
  | "summaryWakeThirtyDayAvgMinutes_DESC"
  | "summaryAsleepCount_ASC"
  | "summaryAsleepCount_DESC"
  | "summaryAsleepMinutes_ASC"
  | "summaryAsleepMinutes_DESC"
  | "summaryAwakeCount_ASC"
  | "summaryAwakeCount_DESC"
  | "summaryAwakeMinutes_ASC"
  | "summaryAwakeMinutes_DESC"
  | "summaryRestlessCount_ASC"
  | "summaryRestlessCount_DESC"
  | "summaryRestlessMinutes_ASC"
  | "summaryRestlessMinutes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface DistanceLogCreateInput {
  date: DateTimeInput;
  totalDistance: Float;
  intradayData?: DistanceDataCreateManyInput;
}

export type CalorieDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DistanceDataUpdateManyWithWhereNestedInput {
  where: DistanceDataScalarWhereInput;
  data: DistanceDataUpdateManyDataInput;
}

export interface CalorieLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  totalCalories?: Float;
  totalCalories_not?: Float;
  totalCalories_in?: Float[] | Float;
  totalCalories_not_in?: Float[] | Float;
  totalCalories_lt?: Float;
  totalCalories_lte?: Float;
  totalCalories_gt?: Float;
  totalCalories_gte?: Float;
  intradayData_every?: CalorieDataWhereInput;
  intradayData_some?: CalorieDataWhereInput;
  intradayData_none?: CalorieDataWhereInput;
  AND?: CalorieLogWhereInput[] | CalorieLogWhereInput;
  OR?: CalorieLogWhereInput[] | CalorieLogWhereInput;
  NOT?: CalorieLogWhereInput[] | CalorieLogWhereInput;
}

export type StepLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SleepDataCreateInput {
  sleepLogId: ID_Input;
  dateTime: DateTimeInput;
  level: String;
  second: Int;
}

export interface StepDataUpdateInput {
  stepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  steps?: Int;
}

export interface DistanceDataUpdateManyDataInput {
  distanceLogId?: ID_Input;
  dateTime?: DateTimeInput;
  distance?: Float;
}

export interface StepLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  totalSteps?: Int;
  totalSteps_not?: Int;
  totalSteps_in?: Int[] | Int;
  totalSteps_not_in?: Int[] | Int;
  totalSteps_lt?: Int;
  totalSteps_lte?: Int;
  totalSteps_gt?: Int;
  totalSteps_gte?: Int;
  intradayData_every?: StepDataWhereInput;
  intradayData_some?: StepDataWhereInput;
  intradayData_none?: StepDataWhereInput;
  AND?: StepLogWhereInput[] | StepLogWhereInput;
  OR?: StepLogWhereInput[] | StepLogWhereInput;
  NOT?: StepLogWhereInput[] | StepLogWhereInput;
}

export type DistanceDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StepDataCreateInput {
  stepLogId: ID_Input;
  dateTime: DateTimeInput;
  steps: Int;
}

export interface DistanceDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  distanceLogId?: ID_Input;
  distanceLogId_not?: ID_Input;
  distanceLogId_in?: ID_Input[] | ID_Input;
  distanceLogId_not_in?: ID_Input[] | ID_Input;
  distanceLogId_lt?: ID_Input;
  distanceLogId_lte?: ID_Input;
  distanceLogId_gt?: ID_Input;
  distanceLogId_gte?: ID_Input;
  distanceLogId_contains?: ID_Input;
  distanceLogId_not_contains?: ID_Input;
  distanceLogId_starts_with?: ID_Input;
  distanceLogId_not_starts_with?: ID_Input;
  distanceLogId_ends_with?: ID_Input;
  distanceLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  distance?: Float;
  distance_not?: Float;
  distance_in?: Float[] | Float;
  distance_not_in?: Float[] | Float;
  distance_lt?: Float;
  distance_lte?: Float;
  distance_gt?: Float;
  distance_gte?: Float;
  AND?: DistanceDataWhereInput[] | DistanceDataWhereInput;
  OR?: DistanceDataWhereInput[] | DistanceDataWhereInput;
  NOT?: DistanceDataWhereInput[] | DistanceDataWhereInput;
}

export interface SleepLogUpdateManyMutationInput {
  userId?: ID_Input;
  dateOfSleep?: String;
  duration?: Int;
  efficiency?: Int;
  isMainSleep?: Boolean;
  logId?: Float;
  minutesAfterWakeup?: Int;
  minutesAsleep?: Int;
  minutesAwake?: Int;
  minutesToFallAsleep?: Int;
  startTime?: DateTimeInput;
  timeInBed?: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface StepDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StepDataWhereInput;
  AND?: StepDataSubscriptionWhereInput[] | StepDataSubscriptionWhereInput;
  OR?: StepDataSubscriptionWhereInput[] | StepDataSubscriptionWhereInput;
  NOT?: StepDataSubscriptionWhereInput[] | StepDataSubscriptionWhereInput;
}

export interface SleepDataUpdateManyDataInput {
  sleepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  level?: String;
  second?: Int;
}

export interface SleepDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SleepDataWhereInput;
  AND?: SleepDataSubscriptionWhereInput[] | SleepDataSubscriptionWhereInput;
  OR?: SleepDataSubscriptionWhereInput[] | SleepDataSubscriptionWhereInput;
  NOT?: SleepDataSubscriptionWhereInput[] | SleepDataSubscriptionWhereInput;
}

export interface SleepDataUpdateManyWithWhereNestedInput {
  where: SleepDataScalarWhereInput;
  data: SleepDataUpdateManyDataInput;
}

export interface HeartLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HeartLogWhereInput;
  AND?: HeartLogSubscriptionWhereInput[] | HeartLogSubscriptionWhereInput;
  OR?: HeartLogSubscriptionWhereInput[] | HeartLogSubscriptionWhereInput;
  NOT?: HeartLogSubscriptionWhereInput[] | HeartLogSubscriptionWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface HeartDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HeartDataWhereInput;
  AND?: HeartDataSubscriptionWhereInput[] | HeartDataSubscriptionWhereInput;
  OR?: HeartDataSubscriptionWhereInput[] | HeartDataSubscriptionWhereInput;
  NOT?: HeartDataSubscriptionWhereInput[] | HeartDataSubscriptionWhereInput;
}

export interface SleepDataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  sleepLogId?: ID_Input;
  sleepLogId_not?: ID_Input;
  sleepLogId_in?: ID_Input[] | ID_Input;
  sleepLogId_not_in?: ID_Input[] | ID_Input;
  sleepLogId_lt?: ID_Input;
  sleepLogId_lte?: ID_Input;
  sleepLogId_gt?: ID_Input;
  sleepLogId_gte?: ID_Input;
  sleepLogId_contains?: ID_Input;
  sleepLogId_not_contains?: ID_Input;
  sleepLogId_starts_with?: ID_Input;
  sleepLogId_not_starts_with?: ID_Input;
  sleepLogId_ends_with?: ID_Input;
  sleepLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  level?: String;
  level_not?: String;
  level_in?: String[] | String;
  level_not_in?: String[] | String;
  level_lt?: String;
  level_lte?: String;
  level_gt?: String;
  level_gte?: String;
  level_contains?: String;
  level_not_contains?: String;
  level_starts_with?: String;
  level_not_starts_with?: String;
  level_ends_with?: String;
  level_not_ends_with?: String;
  second?: Int;
  second_not?: Int;
  second_in?: Int[] | Int;
  second_not_in?: Int[] | Int;
  second_lt?: Int;
  second_lte?: Int;
  second_gt?: Int;
  second_gte?: Int;
  AND?: SleepDataScalarWhereInput[] | SleepDataScalarWhereInput;
  OR?: SleepDataScalarWhereInput[] | SleepDataScalarWhereInput;
  NOT?: SleepDataScalarWhereInput[] | SleepDataScalarWhereInput;
}

export interface FitbitAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FitbitAccountWhereInput;
  AND?:
    | FitbitAccountSubscriptionWhereInput[]
    | FitbitAccountSubscriptionWhereInput;
  OR?:
    | FitbitAccountSubscriptionWhereInput[]
    | FitbitAccountSubscriptionWhereInput;
  NOT?:
    | FitbitAccountSubscriptionWhereInput[]
    | FitbitAccountSubscriptionWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  googleFitAccount?: GoogleFitAccountWhereInput;
  fitbitAccount?: FitbitAccountWhereInput;
  sleepLogs_every?: SleepLogWhereInput;
  sleepLogs_some?: SleepLogWhereInput;
  sleepLogs_none?: SleepLogWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export type FitbitAccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  userId?: ID_Input;
}>;

export interface SleepDataUpsertWithWhereUniqueNestedInput {
  where: SleepDataWhereUniqueInput;
  update: SleepDataUpdateDataInput;
  create: SleepDataCreateInput;
}

export interface FitbitAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  fitbitUserId?: String;
  fitbitUserId_not?: String;
  fitbitUserId_in?: String[] | String;
  fitbitUserId_not_in?: String[] | String;
  fitbitUserId_lt?: String;
  fitbitUserId_lte?: String;
  fitbitUserId_gt?: String;
  fitbitUserId_gte?: String;
  fitbitUserId_contains?: String;
  fitbitUserId_not_contains?: String;
  fitbitUserId_starts_with?: String;
  fitbitUserId_not_starts_with?: String;
  fitbitUserId_ends_with?: String;
  fitbitUserId_not_ends_with?: String;
  refreshToken?: String;
  refreshToken_not?: String;
  refreshToken_in?: String[] | String;
  refreshToken_not_in?: String[] | String;
  refreshToken_lt?: String;
  refreshToken_lte?: String;
  refreshToken_gt?: String;
  refreshToken_gte?: String;
  refreshToken_contains?: String;
  refreshToken_not_contains?: String;
  refreshToken_starts_with?: String;
  refreshToken_not_starts_with?: String;
  refreshToken_ends_with?: String;
  refreshToken_not_ends_with?: String;
  accessToken?: String;
  accessToken_not?: String;
  accessToken_in?: String[] | String;
  accessToken_not_in?: String[] | String;
  accessToken_lt?: String;
  accessToken_lte?: String;
  accessToken_gt?: String;
  accessToken_gte?: String;
  accessToken_contains?: String;
  accessToken_not_contains?: String;
  accessToken_starts_with?: String;
  accessToken_not_starts_with?: String;
  accessToken_ends_with?: String;
  accessToken_not_ends_with?: String;
  expiration?: DateTimeInput;
  expiration_not?: DateTimeInput;
  expiration_in?: DateTimeInput[] | DateTimeInput;
  expiration_not_in?: DateTimeInput[] | DateTimeInput;
  expiration_lt?: DateTimeInput;
  expiration_lte?: DateTimeInput;
  expiration_gt?: DateTimeInput;
  expiration_gte?: DateTimeInput;
  AND?: FitbitAccountWhereInput[] | FitbitAccountWhereInput;
  OR?: FitbitAccountWhereInput[] | FitbitAccountWhereInput;
  NOT?: FitbitAccountWhereInput[] | FitbitAccountWhereInput;
}

export interface SleepDataUpdateDataInput {
  sleepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  level?: String;
  second?: Int;
}

export interface CalorieDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CalorieDataWhereInput;
  AND?: CalorieDataSubscriptionWhereInput[] | CalorieDataSubscriptionWhereInput;
  OR?: CalorieDataSubscriptionWhereInput[] | CalorieDataSubscriptionWhereInput;
  NOT?: CalorieDataSubscriptionWhereInput[] | CalorieDataSubscriptionWhereInput;
}

export interface SleepDataUpdateWithWhereUniqueNestedInput {
  where: SleepDataWhereUniqueInput;
  data: SleepDataUpdateDataInput;
}

export interface SleepLogUpdateManyDataInput {
  userId?: ID_Input;
  dateOfSleep?: String;
  duration?: Int;
  efficiency?: Int;
  isMainSleep?: Boolean;
  logId?: Float;
  minutesAfterWakeup?: Int;
  minutesAsleep?: Int;
  minutesAwake?: Int;
  minutesToFallAsleep?: Int;
  startTime?: DateTimeInput;
  timeInBed?: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepDataUpdateManyInput {
  create?: SleepDataCreateInput[] | SleepDataCreateInput;
  update?:
    | SleepDataUpdateWithWhereUniqueNestedInput[]
    | SleepDataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SleepDataUpsertWithWhereUniqueNestedInput[]
    | SleepDataUpsertWithWhereUniqueNestedInput;
  delete?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
  connect?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
  disconnect?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
  deleteMany?: SleepDataScalarWhereInput[] | SleepDataScalarWhereInput;
  updateMany?:
    | SleepDataUpdateManyWithWhereNestedInput[]
    | SleepDataUpdateManyWithWhereNestedInput;
}

export interface SleepLogUpdateManyWithWhereNestedInput {
  where: SleepLogScalarWhereInput;
  data: SleepLogUpdateManyDataInput;
}

export interface SleepLogScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  dateOfSleep?: String;
  dateOfSleep_not?: String;
  dateOfSleep_in?: String[] | String;
  dateOfSleep_not_in?: String[] | String;
  dateOfSleep_lt?: String;
  dateOfSleep_lte?: String;
  dateOfSleep_gt?: String;
  dateOfSleep_gte?: String;
  dateOfSleep_contains?: String;
  dateOfSleep_not_contains?: String;
  dateOfSleep_starts_with?: String;
  dateOfSleep_not_starts_with?: String;
  dateOfSleep_ends_with?: String;
  dateOfSleep_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  efficiency?: Int;
  efficiency_not?: Int;
  efficiency_in?: Int[] | Int;
  efficiency_not_in?: Int[] | Int;
  efficiency_lt?: Int;
  efficiency_lte?: Int;
  efficiency_gt?: Int;
  efficiency_gte?: Int;
  isMainSleep?: Boolean;
  isMainSleep_not?: Boolean;
  logId?: Float;
  logId_not?: Float;
  logId_in?: Float[] | Float;
  logId_not_in?: Float[] | Float;
  logId_lt?: Float;
  logId_lte?: Float;
  logId_gt?: Float;
  logId_gte?: Float;
  minutesAfterWakeup?: Int;
  minutesAfterWakeup_not?: Int;
  minutesAfterWakeup_in?: Int[] | Int;
  minutesAfterWakeup_not_in?: Int[] | Int;
  minutesAfterWakeup_lt?: Int;
  minutesAfterWakeup_lte?: Int;
  minutesAfterWakeup_gt?: Int;
  minutesAfterWakeup_gte?: Int;
  minutesAsleep?: Int;
  minutesAsleep_not?: Int;
  minutesAsleep_in?: Int[] | Int;
  minutesAsleep_not_in?: Int[] | Int;
  minutesAsleep_lt?: Int;
  minutesAsleep_lte?: Int;
  minutesAsleep_gt?: Int;
  minutesAsleep_gte?: Int;
  minutesAwake?: Int;
  minutesAwake_not?: Int;
  minutesAwake_in?: Int[] | Int;
  minutesAwake_not_in?: Int[] | Int;
  minutesAwake_lt?: Int;
  minutesAwake_lte?: Int;
  minutesAwake_gt?: Int;
  minutesAwake_gte?: Int;
  minutesToFallAsleep?: Int;
  minutesToFallAsleep_not?: Int;
  minutesToFallAsleep_in?: Int[] | Int;
  minutesToFallAsleep_not_in?: Int[] | Int;
  minutesToFallAsleep_lt?: Int;
  minutesToFallAsleep_lte?: Int;
  minutesToFallAsleep_gt?: Int;
  minutesToFallAsleep_gte?: Int;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  timeInBed?: Int;
  timeInBed_not?: Int;
  timeInBed_in?: Int[] | Int;
  timeInBed_not_in?: Int[] | Int;
  timeInBed_lt?: Int;
  timeInBed_lte?: Int;
  timeInBed_gt?: Int;
  timeInBed_gte?: Int;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  summaryDeepCount?: Int;
  summaryDeepCount_not?: Int;
  summaryDeepCount_in?: Int[] | Int;
  summaryDeepCount_not_in?: Int[] | Int;
  summaryDeepCount_lt?: Int;
  summaryDeepCount_lte?: Int;
  summaryDeepCount_gt?: Int;
  summaryDeepCount_gte?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepMinutes_not?: Int;
  summaryDeepMinutes_in?: Int[] | Int;
  summaryDeepMinutes_not_in?: Int[] | Int;
  summaryDeepMinutes_lt?: Int;
  summaryDeepMinutes_lte?: Int;
  summaryDeepMinutes_gt?: Int;
  summaryDeepMinutes_gte?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes_not?: Int;
  summaryDeepThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryDeepThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryDeepThirtyDayAvgMinutes_lt?: Int;
  summaryDeepThirtyDayAvgMinutes_lte?: Int;
  summaryDeepThirtyDayAvgMinutes_gt?: Int;
  summaryDeepThirtyDayAvgMinutes_gte?: Int;
  summaryLightCount?: Int;
  summaryLightCount_not?: Int;
  summaryLightCount_in?: Int[] | Int;
  summaryLightCount_not_in?: Int[] | Int;
  summaryLightCount_lt?: Int;
  summaryLightCount_lte?: Int;
  summaryLightCount_gt?: Int;
  summaryLightCount_gte?: Int;
  summaryLightMinutes?: Int;
  summaryLightMinutes_not?: Int;
  summaryLightMinutes_in?: Int[] | Int;
  summaryLightMinutes_not_in?: Int[] | Int;
  summaryLightMinutes_lt?: Int;
  summaryLightMinutes_lte?: Int;
  summaryLightMinutes_gt?: Int;
  summaryLightMinutes_gte?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryLightThirtyDayAvgMinutes_not?: Int;
  summaryLightThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryLightThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryLightThirtyDayAvgMinutes_lt?: Int;
  summaryLightThirtyDayAvgMinutes_lte?: Int;
  summaryLightThirtyDayAvgMinutes_gt?: Int;
  summaryLightThirtyDayAvgMinutes_gte?: Int;
  summaryRemCount?: Int;
  summaryRemCount_not?: Int;
  summaryRemCount_in?: Int[] | Int;
  summaryRemCount_not_in?: Int[] | Int;
  summaryRemCount_lt?: Int;
  summaryRemCount_lte?: Int;
  summaryRemCount_gt?: Int;
  summaryRemCount_gte?: Int;
  summaryRemMinutes?: Int;
  summaryRemMinutes_not?: Int;
  summaryRemMinutes_in?: Int[] | Int;
  summaryRemMinutes_not_in?: Int[] | Int;
  summaryRemMinutes_lt?: Int;
  summaryRemMinutes_lte?: Int;
  summaryRemMinutes_gt?: Int;
  summaryRemMinutes_gte?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryRemThirtyDayAvgMinutes_not?: Int;
  summaryRemThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryRemThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryRemThirtyDayAvgMinutes_lt?: Int;
  summaryRemThirtyDayAvgMinutes_lte?: Int;
  summaryRemThirtyDayAvgMinutes_gt?: Int;
  summaryRemThirtyDayAvgMinutes_gte?: Int;
  summaryWakeCount?: Int;
  summaryWakeCount_not?: Int;
  summaryWakeCount_in?: Int[] | Int;
  summaryWakeCount_not_in?: Int[] | Int;
  summaryWakeCount_lt?: Int;
  summaryWakeCount_lte?: Int;
  summaryWakeCount_gt?: Int;
  summaryWakeCount_gte?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeMinutes_not?: Int;
  summaryWakeMinutes_in?: Int[] | Int;
  summaryWakeMinutes_not_in?: Int[] | Int;
  summaryWakeMinutes_lt?: Int;
  summaryWakeMinutes_lte?: Int;
  summaryWakeMinutes_gt?: Int;
  summaryWakeMinutes_gte?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes_not?: Int;
  summaryWakeThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryWakeThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryWakeThirtyDayAvgMinutes_lt?: Int;
  summaryWakeThirtyDayAvgMinutes_lte?: Int;
  summaryWakeThirtyDayAvgMinutes_gt?: Int;
  summaryWakeThirtyDayAvgMinutes_gte?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepCount_not?: Int;
  summaryAsleepCount_in?: Int[] | Int;
  summaryAsleepCount_not_in?: Int[] | Int;
  summaryAsleepCount_lt?: Int;
  summaryAsleepCount_lte?: Int;
  summaryAsleepCount_gt?: Int;
  summaryAsleepCount_gte?: Int;
  summaryAsleepMinutes?: Int;
  summaryAsleepMinutes_not?: Int;
  summaryAsleepMinutes_in?: Int[] | Int;
  summaryAsleepMinutes_not_in?: Int[] | Int;
  summaryAsleepMinutes_lt?: Int;
  summaryAsleepMinutes_lte?: Int;
  summaryAsleepMinutes_gt?: Int;
  summaryAsleepMinutes_gte?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeCount_not?: Int;
  summaryAwakeCount_in?: Int[] | Int;
  summaryAwakeCount_not_in?: Int[] | Int;
  summaryAwakeCount_lt?: Int;
  summaryAwakeCount_lte?: Int;
  summaryAwakeCount_gt?: Int;
  summaryAwakeCount_gte?: Int;
  summaryAwakeMinutes?: Int;
  summaryAwakeMinutes_not?: Int;
  summaryAwakeMinutes_in?: Int[] | Int;
  summaryAwakeMinutes_not_in?: Int[] | Int;
  summaryAwakeMinutes_lt?: Int;
  summaryAwakeMinutes_lte?: Int;
  summaryAwakeMinutes_gt?: Int;
  summaryAwakeMinutes_gte?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessCount_not?: Int;
  summaryRestlessCount_in?: Int[] | Int;
  summaryRestlessCount_not_in?: Int[] | Int;
  summaryRestlessCount_lt?: Int;
  summaryRestlessCount_lte?: Int;
  summaryRestlessCount_gt?: Int;
  summaryRestlessCount_gte?: Int;
  summaryRestlessMinutes?: Int;
  summaryRestlessMinutes_not?: Int;
  summaryRestlessMinutes_in?: Int[] | Int;
  summaryRestlessMinutes_not_in?: Int[] | Int;
  summaryRestlessMinutes_lt?: Int;
  summaryRestlessMinutes_lte?: Int;
  summaryRestlessMinutes_gt?: Int;
  summaryRestlessMinutes_gte?: Int;
  AND?: SleepLogScalarWhereInput[] | SleepLogScalarWhereInput;
  OR?: SleepLogScalarWhereInput[] | SleepLogScalarWhereInput;
  NOT?: SleepLogScalarWhereInput[] | SleepLogScalarWhereInput;
}

export interface SleepLogUpdateDataInput {
  userId?: ID_Input;
  dateOfSleep?: String;
  duration?: Int;
  efficiency?: Int;
  isMainSleep?: Boolean;
  logId?: Float;
  minutesAfterWakeup?: Int;
  minutesAsleep?: Int;
  minutesAwake?: Int;
  minutesToFallAsleep?: Int;
  startTime?: DateTimeInput;
  timeInBed?: Int;
  type?: String;
  data?: SleepDataUpdateManyInput;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface CalorieDataCreateInput {
  calorieLogId: ID_Input;
  dateTime: DateTimeInput;
  calories: Float;
}

export type HeartDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CalorieDataUpdateInput {
  calorieLogId?: ID_Input;
  dateTime?: DateTimeInput;
  calories?: Float;
}

export interface HeartDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  heartLogId?: ID_Input;
  heartLogId_not?: ID_Input;
  heartLogId_in?: ID_Input[] | ID_Input;
  heartLogId_not_in?: ID_Input[] | ID_Input;
  heartLogId_lt?: ID_Input;
  heartLogId_lte?: ID_Input;
  heartLogId_gt?: ID_Input;
  heartLogId_gte?: ID_Input;
  heartLogId_contains?: ID_Input;
  heartLogId_not_contains?: ID_Input;
  heartLogId_starts_with?: ID_Input;
  heartLogId_not_starts_with?: ID_Input;
  heartLogId_ends_with?: ID_Input;
  heartLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  heartRate?: Float;
  heartRate_not?: Float;
  heartRate_in?: Float[] | Float;
  heartRate_not_in?: Float[] | Float;
  heartRate_lt?: Float;
  heartRate_lte?: Float;
  heartRate_gt?: Float;
  heartRate_gte?: Float;
  AND?: HeartDataWhereInput[] | HeartDataWhereInput;
  OR?: HeartDataWhereInput[] | HeartDataWhereInput;
  NOT?: HeartDataWhereInput[] | HeartDataWhereInput;
}

export interface CalorieDataUpdateManyMutationInput {
  calorieLogId?: ID_Input;
  dateTime?: DateTimeInput;
  calories?: Float;
}

export interface FitbitAccountUpdateDataInput {
  userId?: ID_Input;
  fitbitUserId?: String;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface SleepLogUpdateInput {
  userId?: ID_Input;
  dateOfSleep?: String;
  duration?: Int;
  efficiency?: Int;
  isMainSleep?: Boolean;
  logId?: Float;
  minutesAfterWakeup?: Int;
  minutesAsleep?: Int;
  minutesAwake?: Int;
  minutesToFallAsleep?: Int;
  startTime?: DateTimeInput;
  timeInBed?: Int;
  type?: String;
  data?: SleepDataUpdateManyInput;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface GoogleFitAccountUpsertNestedInput {
  update: GoogleFitAccountUpdateDataInput;
  create: GoogleFitAccountCreateInput;
}

export interface SleepDataCreateManyInput {
  create?: SleepDataCreateInput[] | SleepDataCreateInput;
  connect?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
}

export interface GoogleFitAccountUpdateDataInput {
  userId?: ID_Input;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface CalorieLogCreateInput {
  date: DateTimeInput;
  totalCalories: Float;
  intradayData?: CalorieDataCreateManyInput;
}

export interface GoogleFitAccountUpdateOneInput {
  create?: GoogleFitAccountCreateInput;
  update?: GoogleFitAccountUpdateDataInput;
  upsert?: GoogleFitAccountUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GoogleFitAccountWhereUniqueInput;
}

export interface CalorieDataCreateManyInput {
  create?: CalorieDataCreateInput[] | CalorieDataCreateInput;
  connect?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
}

export interface SleepLogCreateManyInput {
  create?: SleepLogCreateInput[] | SleepLogCreateInput;
  connect?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
}

export interface CalorieLogUpdateInput {
  date?: DateTimeInput;
  totalCalories?: Float;
  intradayData?: CalorieDataUpdateManyInput;
}

export type SleepDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CalorieDataUpdateManyInput {
  create?: CalorieDataCreateInput[] | CalorieDataCreateInput;
  update?:
    | CalorieDataUpdateWithWhereUniqueNestedInput[]
    | CalorieDataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CalorieDataUpsertWithWhereUniqueNestedInput[]
    | CalorieDataUpsertWithWhereUniqueNestedInput;
  delete?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
  connect?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
  disconnect?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
  deleteMany?: CalorieDataScalarWhereInput[] | CalorieDataScalarWhereInput;
  updateMany?:
    | CalorieDataUpdateManyWithWhereNestedInput[]
    | CalorieDataUpdateManyWithWhereNestedInput;
}

export interface SleepDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  sleepLogId?: ID_Input;
  sleepLogId_not?: ID_Input;
  sleepLogId_in?: ID_Input[] | ID_Input;
  sleepLogId_not_in?: ID_Input[] | ID_Input;
  sleepLogId_lt?: ID_Input;
  sleepLogId_lte?: ID_Input;
  sleepLogId_gt?: ID_Input;
  sleepLogId_gte?: ID_Input;
  sleepLogId_contains?: ID_Input;
  sleepLogId_not_contains?: ID_Input;
  sleepLogId_starts_with?: ID_Input;
  sleepLogId_not_starts_with?: ID_Input;
  sleepLogId_ends_with?: ID_Input;
  sleepLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  level?: String;
  level_not?: String;
  level_in?: String[] | String;
  level_not_in?: String[] | String;
  level_lt?: String;
  level_lte?: String;
  level_gt?: String;
  level_gte?: String;
  level_contains?: String;
  level_not_contains?: String;
  level_starts_with?: String;
  level_not_starts_with?: String;
  level_ends_with?: String;
  level_not_ends_with?: String;
  second?: Int;
  second_not?: Int;
  second_in?: Int[] | Int;
  second_not_in?: Int[] | Int;
  second_lt?: Int;
  second_lte?: Int;
  second_gt?: Int;
  second_gte?: Int;
  AND?: SleepDataWhereInput[] | SleepDataWhereInput;
  OR?: SleepDataWhereInput[] | SleepDataWhereInput;
  NOT?: SleepDataWhereInput[] | SleepDataWhereInput;
}

export interface CalorieDataUpdateWithWhereUniqueNestedInput {
  where: CalorieDataWhereUniqueInput;
  data: CalorieDataUpdateDataInput;
}

export interface StepLogUpdateManyMutationInput {
  date?: DateTimeInput;
  totalSteps?: Int;
}

export interface CalorieDataUpdateDataInput {
  calorieLogId?: ID_Input;
  dateTime?: DateTimeInput;
  calories?: Float;
}

export interface StepDataUpdateManyWithWhereNestedInput {
  where: StepDataScalarWhereInput;
  data: StepDataUpdateManyDataInput;
}

export interface CalorieDataUpsertWithWhereUniqueNestedInput {
  where: CalorieDataWhereUniqueInput;
  update: CalorieDataUpdateDataInput;
  create: CalorieDataCreateInput;
}

export interface StepDataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stepLogId?: ID_Input;
  stepLogId_not?: ID_Input;
  stepLogId_in?: ID_Input[] | ID_Input;
  stepLogId_not_in?: ID_Input[] | ID_Input;
  stepLogId_lt?: ID_Input;
  stepLogId_lte?: ID_Input;
  stepLogId_gt?: ID_Input;
  stepLogId_gte?: ID_Input;
  stepLogId_contains?: ID_Input;
  stepLogId_not_contains?: ID_Input;
  stepLogId_starts_with?: ID_Input;
  stepLogId_not_starts_with?: ID_Input;
  stepLogId_ends_with?: ID_Input;
  stepLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  steps?: Int;
  steps_not?: Int;
  steps_in?: Int[] | Int;
  steps_not_in?: Int[] | Int;
  steps_lt?: Int;
  steps_lte?: Int;
  steps_gt?: Int;
  steps_gte?: Int;
  AND?: StepDataScalarWhereInput[] | StepDataScalarWhereInput;
  OR?: StepDataScalarWhereInput[] | StepDataScalarWhereInput;
  NOT?: StepDataScalarWhereInput[] | StepDataScalarWhereInput;
}

export interface CalorieDataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  calorieLogId?: ID_Input;
  calorieLogId_not?: ID_Input;
  calorieLogId_in?: ID_Input[] | ID_Input;
  calorieLogId_not_in?: ID_Input[] | ID_Input;
  calorieLogId_lt?: ID_Input;
  calorieLogId_lte?: ID_Input;
  calorieLogId_gt?: ID_Input;
  calorieLogId_gte?: ID_Input;
  calorieLogId_contains?: ID_Input;
  calorieLogId_not_contains?: ID_Input;
  calorieLogId_starts_with?: ID_Input;
  calorieLogId_not_starts_with?: ID_Input;
  calorieLogId_ends_with?: ID_Input;
  calorieLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  calories?: Float;
  calories_not?: Float;
  calories_in?: Float[] | Float;
  calories_not_in?: Float[] | Float;
  calories_lt?: Float;
  calories_lte?: Float;
  calories_gt?: Float;
  calories_gte?: Float;
  AND?: CalorieDataScalarWhereInput[] | CalorieDataScalarWhereInput;
  OR?: CalorieDataScalarWhereInput[] | CalorieDataScalarWhereInput;
  NOT?: CalorieDataScalarWhereInput[] | CalorieDataScalarWhereInput;
}

export interface StepDataUpsertWithWhereUniqueNestedInput {
  where: StepDataWhereUniqueInput;
  update: StepDataUpdateDataInput;
  create: StepDataCreateInput;
}

export interface CalorieDataUpdateManyWithWhereNestedInput {
  where: CalorieDataScalarWhereInput;
  data: CalorieDataUpdateManyDataInput;
}

export interface StepDataUpdateWithWhereUniqueNestedInput {
  where: StepDataWhereUniqueInput;
  data: StepDataUpdateDataInput;
}

export interface CalorieDataUpdateManyDataInput {
  calorieLogId?: ID_Input;
  dateTime?: DateTimeInput;
  calories?: Float;
}

export type StepDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CalorieLogUpdateManyMutationInput {
  date?: DateTimeInput;
  totalCalories?: Float;
}

export interface StepDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stepLogId?: ID_Input;
  stepLogId_not?: ID_Input;
  stepLogId_in?: ID_Input[] | ID_Input;
  stepLogId_not_in?: ID_Input[] | ID_Input;
  stepLogId_lt?: ID_Input;
  stepLogId_lte?: ID_Input;
  stepLogId_gt?: ID_Input;
  stepLogId_gte?: ID_Input;
  stepLogId_contains?: ID_Input;
  stepLogId_not_contains?: ID_Input;
  stepLogId_starts_with?: ID_Input;
  stepLogId_not_starts_with?: ID_Input;
  stepLogId_ends_with?: ID_Input;
  stepLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  steps?: Int;
  steps_not?: Int;
  steps_in?: Int[] | Int;
  steps_not_in?: Int[] | Int;
  steps_lt?: Int;
  steps_lte?: Int;
  steps_gt?: Int;
  steps_gte?: Int;
  AND?: StepDataWhereInput[] | StepDataWhereInput;
  OR?: StepDataWhereInput[] | StepDataWhereInput;
  NOT?: StepDataWhereInput[] | StepDataWhereInput;
}

export interface DistanceDataCreateInput {
  distanceLogId: ID_Input;
  dateTime: DateTimeInput;
  distance: Float;
}

export interface StepDataCreateManyInput {
  create?: StepDataCreateInput[] | StepDataCreateInput;
  connect?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
}

export interface DistanceDataUpdateInput {
  distanceLogId?: ID_Input;
  dateTime?: DateTimeInput;
  distance?: Float;
}

export interface StepDataUpdateManyMutationInput {
  stepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  steps?: Int;
}

export interface DistanceDataUpdateManyMutationInput {
  distanceLogId?: ID_Input;
  dateTime?: DateTimeInput;
  distance?: Float;
}

export interface StepLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StepLogWhereInput;
  AND?: StepLogSubscriptionWhereInput[] | StepLogSubscriptionWhereInput;
  OR?: StepLogSubscriptionWhereInput[] | StepLogSubscriptionWhereInput;
  NOT?: StepLogSubscriptionWhereInput[] | StepLogSubscriptionWhereInput;
}

export interface SleepLogCreateInput {
  userId: ID_Input;
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeInput;
  timeInBed: Int;
  type?: String;
  data?: SleepDataCreateManyInput;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SleepLogWhereInput;
  AND?: SleepLogSubscriptionWhereInput[] | SleepLogSubscriptionWhereInput;
  OR?: SleepLogSubscriptionWhereInput[] | SleepLogSubscriptionWhereInput;
  NOT?: SleepLogSubscriptionWhereInput[] | SleepLogSubscriptionWhereInput;
}

export interface DistanceDataCreateManyInput {
  create?: DistanceDataCreateInput[] | DistanceDataCreateInput;
  connect?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
}

export interface DistanceLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  totalDistance?: Float;
  totalDistance_not?: Float;
  totalDistance_in?: Float[] | Float;
  totalDistance_not_in?: Float[] | Float;
  totalDistance_lt?: Float;
  totalDistance_lte?: Float;
  totalDistance_gt?: Float;
  totalDistance_gte?: Float;
  intradayData_every?: DistanceDataWhereInput;
  intradayData_some?: DistanceDataWhereInput;
  intradayData_none?: DistanceDataWhereInput;
  AND?: DistanceLogWhereInput[] | DistanceLogWhereInput;
  OR?: DistanceLogWhereInput[] | DistanceLogWhereInput;
  NOT?: DistanceLogWhereInput[] | DistanceLogWhereInput;
}

export interface DistanceLogUpdateInput {
  date?: DateTimeInput;
  totalDistance?: Float;
  intradayData?: DistanceDataUpdateManyInput;
}

export interface DistanceLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DistanceLogWhereInput;
  AND?: DistanceLogSubscriptionWhereInput[] | DistanceLogSubscriptionWhereInput;
  OR?: DistanceLogSubscriptionWhereInput[] | DistanceLogSubscriptionWhereInput;
  NOT?: DistanceLogSubscriptionWhereInput[] | DistanceLogSubscriptionWhereInput;
}

export interface DistanceDataUpdateManyInput {
  create?: DistanceDataCreateInput[] | DistanceDataCreateInput;
  update?:
    | DistanceDataUpdateWithWhereUniqueNestedInput[]
    | DistanceDataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DistanceDataUpsertWithWhereUniqueNestedInput[]
    | DistanceDataUpsertWithWhereUniqueNestedInput;
  delete?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
  connect?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
  disconnect?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
  deleteMany?: DistanceDataScalarWhereInput[] | DistanceDataScalarWhereInput;
  updateMany?:
    | DistanceDataUpdateManyWithWhereNestedInput[]
    | DistanceDataUpdateManyWithWhereNestedInput;
}

export interface CalorieLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CalorieLogWhereInput;
  AND?: CalorieLogSubscriptionWhereInput[] | CalorieLogSubscriptionWhereInput;
  OR?: CalorieLogSubscriptionWhereInput[] | CalorieLogSubscriptionWhereInput;
  NOT?: CalorieLogSubscriptionWhereInput[] | CalorieLogSubscriptionWhereInput;
}

export interface DistanceDataUpdateWithWhereUniqueNestedInput {
  where: DistanceDataWhereUniqueInput;
  data: DistanceDataUpdateDataInput;
}

export type GoogleFitAccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  userId?: ID_Input;
}>;

export interface DistanceDataUpdateDataInput {
  distanceLogId?: ID_Input;
  dateTime?: DateTimeInput;
  distance?: Float;
}

export interface SleepLogUpsertWithWhereUniqueNestedInput {
  where: SleepLogWhereUniqueInput;
  update: SleepLogUpdateDataInput;
  create: SleepLogCreateInput;
}

export interface DistanceDataUpsertWithWhereUniqueNestedInput {
  where: DistanceDataWhereUniqueInput;
  update: DistanceDataUpdateDataInput;
  create: DistanceDataCreateInput;
}

export interface SleepLogUpdateManyInput {
  create?: SleepLogCreateInput[] | SleepLogCreateInput;
  update?:
    | SleepLogUpdateWithWhereUniqueNestedInput[]
    | SleepLogUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SleepLogUpsertWithWhereUniqueNestedInput[]
    | SleepLogUpsertWithWhereUniqueNestedInput;
  delete?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
  connect?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
  disconnect?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
  deleteMany?: SleepLogScalarWhereInput[] | SleepLogScalarWhereInput;
  updateMany?:
    | SleepLogUpdateManyWithWhereNestedInput[]
    | SleepLogUpdateManyWithWhereNestedInput;
}

export interface DistanceDataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  distanceLogId?: ID_Input;
  distanceLogId_not?: ID_Input;
  distanceLogId_in?: ID_Input[] | ID_Input;
  distanceLogId_not_in?: ID_Input[] | ID_Input;
  distanceLogId_lt?: ID_Input;
  distanceLogId_lte?: ID_Input;
  distanceLogId_gt?: ID_Input;
  distanceLogId_gte?: ID_Input;
  distanceLogId_contains?: ID_Input;
  distanceLogId_not_contains?: ID_Input;
  distanceLogId_starts_with?: ID_Input;
  distanceLogId_not_starts_with?: ID_Input;
  distanceLogId_ends_with?: ID_Input;
  distanceLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  distance?: Float;
  distance_not?: Float;
  distance_in?: Float[] | Float;
  distance_not_in?: Float[] | Float;
  distance_lt?: Float;
  distance_lte?: Float;
  distance_gt?: Float;
  distance_gte?: Float;
  AND?: DistanceDataScalarWhereInput[] | DistanceDataScalarWhereInput;
  OR?: DistanceDataScalarWhereInput[] | DistanceDataScalarWhereInput;
  NOT?: DistanceDataScalarWhereInput[] | DistanceDataScalarWhereInput;
}

export interface FitbitAccountUpdateOneInput {
  create?: FitbitAccountCreateInput;
  update?: FitbitAccountUpdateDataInput;
  upsert?: FitbitAccountUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FitbitAccountWhereUniqueInput;
}

export interface SleepDataUpdateManyMutationInput {
  sleepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  level?: String;
  second?: Int;
}

export interface HeartLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  caloriesOutOfRange?: Int;
  caloriesOutOfRange_not?: Int;
  caloriesOutOfRange_in?: Int[] | Int;
  caloriesOutOfRange_not_in?: Int[] | Int;
  caloriesOutOfRange_lt?: Int;
  caloriesOutOfRange_lte?: Int;
  caloriesOutOfRange_gt?: Int;
  caloriesOutOfRange_gte?: Int;
  minutesOutOfRange?: Int;
  minutesOutOfRange_not?: Int;
  minutesOutOfRange_in?: Int[] | Int;
  minutesOutOfRange_not_in?: Int[] | Int;
  minutesOutOfRange_lt?: Int;
  minutesOutOfRange_lte?: Int;
  minutesOutOfRange_gt?: Int;
  minutesOutOfRange_gte?: Int;
  maxValueOutOfRange?: Int;
  maxValueOutOfRange_not?: Int;
  maxValueOutOfRange_in?: Int[] | Int;
  maxValueOutOfRange_not_in?: Int[] | Int;
  maxValueOutOfRange_lt?: Int;
  maxValueOutOfRange_lte?: Int;
  maxValueOutOfRange_gt?: Int;
  maxValueOutOfRange_gte?: Int;
  minValueOutOfRange?: Int;
  minValueOutOfRange_not?: Int;
  minValueOutOfRange_in?: Int[] | Int;
  minValueOutOfRange_not_in?: Int[] | Int;
  minValueOutOfRange_lt?: Int;
  minValueOutOfRange_lte?: Int;
  minValueOutOfRange_gt?: Int;
  minValueOutOfRange_gte?: Int;
  caloriesFatBurn?: Int;
  caloriesFatBurn_not?: Int;
  caloriesFatBurn_in?: Int[] | Int;
  caloriesFatBurn_not_in?: Int[] | Int;
  caloriesFatBurn_lt?: Int;
  caloriesFatBurn_lte?: Int;
  caloriesFatBurn_gt?: Int;
  caloriesFatBurn_gte?: Int;
  minutesFatBurn?: Int;
  minutesFatBurn_not?: Int;
  minutesFatBurn_in?: Int[] | Int;
  minutesFatBurn_not_in?: Int[] | Int;
  minutesFatBurn_lt?: Int;
  minutesFatBurn_lte?: Int;
  minutesFatBurn_gt?: Int;
  minutesFatBurn_gte?: Int;
  maxValueFatBurn?: Int;
  maxValueFatBurn_not?: Int;
  maxValueFatBurn_in?: Int[] | Int;
  maxValueFatBurn_not_in?: Int[] | Int;
  maxValueFatBurn_lt?: Int;
  maxValueFatBurn_lte?: Int;
  maxValueFatBurn_gt?: Int;
  maxValueFatBurn_gte?: Int;
  minValueFatBurn?: Int;
  minValueFatBurn_not?: Int;
  minValueFatBurn_in?: Int[] | Int;
  minValueFatBurn_not_in?: Int[] | Int;
  minValueFatBurn_lt?: Int;
  minValueFatBurn_lte?: Int;
  minValueFatBurn_gt?: Int;
  minValueFatBurn_gte?: Int;
  caloriesCardio?: Int;
  caloriesCardio_not?: Int;
  caloriesCardio_in?: Int[] | Int;
  caloriesCardio_not_in?: Int[] | Int;
  caloriesCardio_lt?: Int;
  caloriesCardio_lte?: Int;
  caloriesCardio_gt?: Int;
  caloriesCardio_gte?: Int;
  minutesCardio?: Int;
  minutesCardio_not?: Int;
  minutesCardio_in?: Int[] | Int;
  minutesCardio_not_in?: Int[] | Int;
  minutesCardio_lt?: Int;
  minutesCardio_lte?: Int;
  minutesCardio_gt?: Int;
  minutesCardio_gte?: Int;
  maxValueCardio?: Int;
  maxValueCardio_not?: Int;
  maxValueCardio_in?: Int[] | Int;
  maxValueCardio_not_in?: Int[] | Int;
  maxValueCardio_lt?: Int;
  maxValueCardio_lte?: Int;
  maxValueCardio_gt?: Int;
  maxValueCardio_gte?: Int;
  minValueCardio?: Int;
  minValueCardio_not?: Int;
  minValueCardio_in?: Int[] | Int;
  minValueCardio_not_in?: Int[] | Int;
  minValueCardio_lt?: Int;
  minValueCardio_lte?: Int;
  minValueCardio_gt?: Int;
  minValueCardio_gte?: Int;
  caloriesPeak?: Int;
  caloriesPeak_not?: Int;
  caloriesPeak_in?: Int[] | Int;
  caloriesPeak_not_in?: Int[] | Int;
  caloriesPeak_lt?: Int;
  caloriesPeak_lte?: Int;
  caloriesPeak_gt?: Int;
  caloriesPeak_gte?: Int;
  minutesPeak?: Int;
  minutesPeak_not?: Int;
  minutesPeak_in?: Int[] | Int;
  minutesPeak_not_in?: Int[] | Int;
  minutesPeak_lt?: Int;
  minutesPeak_lte?: Int;
  minutesPeak_gt?: Int;
  minutesPeak_gte?: Int;
  maxValuePeak?: Int;
  maxValuePeak_not?: Int;
  maxValuePeak_in?: Int[] | Int;
  maxValuePeak_not_in?: Int[] | Int;
  maxValuePeak_lt?: Int;
  maxValuePeak_lte?: Int;
  maxValuePeak_gt?: Int;
  maxValuePeak_gte?: Int;
  minValuePeak?: Int;
  minValuePeak_not?: Int;
  minValuePeak_in?: Int[] | Int;
  minValuePeak_not_in?: Int[] | Int;
  minValuePeak_lt?: Int;
  minValuePeak_lte?: Int;
  minValuePeak_gt?: Int;
  minValuePeak_gte?: Int;
  intradayData_every?: HeartDataWhereInput;
  intradayData_some?: HeartDataWhereInput;
  intradayData_none?: HeartDataWhereInput;
  AND?: HeartLogWhereInput[] | HeartLogWhereInput;
  OR?: HeartLogWhereInput[] | HeartLogWhereInput;
  NOT?: HeartLogWhereInput[] | HeartLogWhereInput;
}

export interface SleepDataUpdateInput {
  sleepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  level?: String;
  second?: Int;
}

export interface FitbitAccountCreateOneInput {
  create?: FitbitAccountCreateInput;
  connect?: FitbitAccountWhereUniqueInput;
}

export interface DistanceLogUpdateManyMutationInput {
  date?: DateTimeInput;
  totalDistance?: Float;
}

export interface UserCreateInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneInput;
  fitbitAccount?: FitbitAccountCreateOneInput;
  sleepLogs?: SleepLogCreateManyInput;
}

export interface FitbitAccountCreateInput {
  userId: ID_Input;
  fitbitUserId: String;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeInput;
}

export type SleepLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  logId?: Float;
}>;

export interface FitbitAccountUpdateInput {
  userId?: ID_Input;
  fitbitUserId?: String;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface StepDataUpdateDataInput {
  stepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  steps?: Int;
}

export interface FitbitAccountUpdateManyMutationInput {
  userId?: ID_Input;
  fitbitUserId?: String;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface StepLogUpdateInput {
  date?: DateTimeInput;
  totalSteps?: Int;
  intradayData?: StepDataUpdateManyInput;
}

export interface GoogleFitAccountCreateInput {
  userId: ID_Input;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeInput;
}

export interface StepLogCreateInput {
  date: DateTimeInput;
  totalSteps: Int;
  intradayData?: StepDataCreateManyInput;
}

export interface GoogleFitAccountUpdateInput {
  userId?: ID_Input;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export type CalorieLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GoogleFitAccountUpdateManyMutationInput {
  userId?: ID_Input;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface GoogleFitAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GoogleFitAccountWhereInput;
  AND?:
    | GoogleFitAccountSubscriptionWhereInput[]
    | GoogleFitAccountSubscriptionWhereInput;
  OR?:
    | GoogleFitAccountSubscriptionWhereInput[]
    | GoogleFitAccountSubscriptionWhereInput;
  NOT?:
    | GoogleFitAccountSubscriptionWhereInput[]
    | GoogleFitAccountSubscriptionWhereInput;
}

export interface HeartDataCreateInput {
  heartLogId: ID_Input;
  dateTime: DateTimeInput;
  heartRate: Float;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  password?: String;
}

export interface HeartDataUpdateInput {
  heartLogId?: ID_Input;
  dateTime?: DateTimeInput;
  heartRate?: Float;
}

export interface SleepLogUpdateWithWhereUniqueNestedInput {
  where: SleepLogWhereUniqueInput;
  data: SleepLogUpdateDataInput;
}

export interface HeartDataUpdateManyMutationInput {
  heartLogId?: ID_Input;
  dateTime?: DateTimeInput;
  heartRate?: Float;
}

export type HeartLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HeartLogCreateInput {
  dateTime: DateTimeInput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
  intradayData?: HeartDataCreateManyInput;
}

export interface GoogleFitAccountCreateOneInput {
  create?: GoogleFitAccountCreateInput;
  connect?: GoogleFitAccountWhereUniqueInput;
}

export interface HeartDataCreateManyInput {
  create?: HeartDataCreateInput[] | HeartDataCreateInput;
  connect?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
}

export interface SleepLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  dateOfSleep?: String;
  dateOfSleep_not?: String;
  dateOfSleep_in?: String[] | String;
  dateOfSleep_not_in?: String[] | String;
  dateOfSleep_lt?: String;
  dateOfSleep_lte?: String;
  dateOfSleep_gt?: String;
  dateOfSleep_gte?: String;
  dateOfSleep_contains?: String;
  dateOfSleep_not_contains?: String;
  dateOfSleep_starts_with?: String;
  dateOfSleep_not_starts_with?: String;
  dateOfSleep_ends_with?: String;
  dateOfSleep_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  efficiency?: Int;
  efficiency_not?: Int;
  efficiency_in?: Int[] | Int;
  efficiency_not_in?: Int[] | Int;
  efficiency_lt?: Int;
  efficiency_lte?: Int;
  efficiency_gt?: Int;
  efficiency_gte?: Int;
  isMainSleep?: Boolean;
  isMainSleep_not?: Boolean;
  logId?: Float;
  logId_not?: Float;
  logId_in?: Float[] | Float;
  logId_not_in?: Float[] | Float;
  logId_lt?: Float;
  logId_lte?: Float;
  logId_gt?: Float;
  logId_gte?: Float;
  minutesAfterWakeup?: Int;
  minutesAfterWakeup_not?: Int;
  minutesAfterWakeup_in?: Int[] | Int;
  minutesAfterWakeup_not_in?: Int[] | Int;
  minutesAfterWakeup_lt?: Int;
  minutesAfterWakeup_lte?: Int;
  minutesAfterWakeup_gt?: Int;
  minutesAfterWakeup_gte?: Int;
  minutesAsleep?: Int;
  minutesAsleep_not?: Int;
  minutesAsleep_in?: Int[] | Int;
  minutesAsleep_not_in?: Int[] | Int;
  minutesAsleep_lt?: Int;
  minutesAsleep_lte?: Int;
  minutesAsleep_gt?: Int;
  minutesAsleep_gte?: Int;
  minutesAwake?: Int;
  minutesAwake_not?: Int;
  minutesAwake_in?: Int[] | Int;
  minutesAwake_not_in?: Int[] | Int;
  minutesAwake_lt?: Int;
  minutesAwake_lte?: Int;
  minutesAwake_gt?: Int;
  minutesAwake_gte?: Int;
  minutesToFallAsleep?: Int;
  minutesToFallAsleep_not?: Int;
  minutesToFallAsleep_in?: Int[] | Int;
  minutesToFallAsleep_not_in?: Int[] | Int;
  minutesToFallAsleep_lt?: Int;
  minutesToFallAsleep_lte?: Int;
  minutesToFallAsleep_gt?: Int;
  minutesToFallAsleep_gte?: Int;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  timeInBed?: Int;
  timeInBed_not?: Int;
  timeInBed_in?: Int[] | Int;
  timeInBed_not_in?: Int[] | Int;
  timeInBed_lt?: Int;
  timeInBed_lte?: Int;
  timeInBed_gt?: Int;
  timeInBed_gte?: Int;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  data_every?: SleepDataWhereInput;
  data_some?: SleepDataWhereInput;
  data_none?: SleepDataWhereInput;
  summaryDeepCount?: Int;
  summaryDeepCount_not?: Int;
  summaryDeepCount_in?: Int[] | Int;
  summaryDeepCount_not_in?: Int[] | Int;
  summaryDeepCount_lt?: Int;
  summaryDeepCount_lte?: Int;
  summaryDeepCount_gt?: Int;
  summaryDeepCount_gte?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepMinutes_not?: Int;
  summaryDeepMinutes_in?: Int[] | Int;
  summaryDeepMinutes_not_in?: Int[] | Int;
  summaryDeepMinutes_lt?: Int;
  summaryDeepMinutes_lte?: Int;
  summaryDeepMinutes_gt?: Int;
  summaryDeepMinutes_gte?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes_not?: Int;
  summaryDeepThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryDeepThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryDeepThirtyDayAvgMinutes_lt?: Int;
  summaryDeepThirtyDayAvgMinutes_lte?: Int;
  summaryDeepThirtyDayAvgMinutes_gt?: Int;
  summaryDeepThirtyDayAvgMinutes_gte?: Int;
  summaryLightCount?: Int;
  summaryLightCount_not?: Int;
  summaryLightCount_in?: Int[] | Int;
  summaryLightCount_not_in?: Int[] | Int;
  summaryLightCount_lt?: Int;
  summaryLightCount_lte?: Int;
  summaryLightCount_gt?: Int;
  summaryLightCount_gte?: Int;
  summaryLightMinutes?: Int;
  summaryLightMinutes_not?: Int;
  summaryLightMinutes_in?: Int[] | Int;
  summaryLightMinutes_not_in?: Int[] | Int;
  summaryLightMinutes_lt?: Int;
  summaryLightMinutes_lte?: Int;
  summaryLightMinutes_gt?: Int;
  summaryLightMinutes_gte?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryLightThirtyDayAvgMinutes_not?: Int;
  summaryLightThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryLightThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryLightThirtyDayAvgMinutes_lt?: Int;
  summaryLightThirtyDayAvgMinutes_lte?: Int;
  summaryLightThirtyDayAvgMinutes_gt?: Int;
  summaryLightThirtyDayAvgMinutes_gte?: Int;
  summaryRemCount?: Int;
  summaryRemCount_not?: Int;
  summaryRemCount_in?: Int[] | Int;
  summaryRemCount_not_in?: Int[] | Int;
  summaryRemCount_lt?: Int;
  summaryRemCount_lte?: Int;
  summaryRemCount_gt?: Int;
  summaryRemCount_gte?: Int;
  summaryRemMinutes?: Int;
  summaryRemMinutes_not?: Int;
  summaryRemMinutes_in?: Int[] | Int;
  summaryRemMinutes_not_in?: Int[] | Int;
  summaryRemMinutes_lt?: Int;
  summaryRemMinutes_lte?: Int;
  summaryRemMinutes_gt?: Int;
  summaryRemMinutes_gte?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryRemThirtyDayAvgMinutes_not?: Int;
  summaryRemThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryRemThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryRemThirtyDayAvgMinutes_lt?: Int;
  summaryRemThirtyDayAvgMinutes_lte?: Int;
  summaryRemThirtyDayAvgMinutes_gt?: Int;
  summaryRemThirtyDayAvgMinutes_gte?: Int;
  summaryWakeCount?: Int;
  summaryWakeCount_not?: Int;
  summaryWakeCount_in?: Int[] | Int;
  summaryWakeCount_not_in?: Int[] | Int;
  summaryWakeCount_lt?: Int;
  summaryWakeCount_lte?: Int;
  summaryWakeCount_gt?: Int;
  summaryWakeCount_gte?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeMinutes_not?: Int;
  summaryWakeMinutes_in?: Int[] | Int;
  summaryWakeMinutes_not_in?: Int[] | Int;
  summaryWakeMinutes_lt?: Int;
  summaryWakeMinutes_lte?: Int;
  summaryWakeMinutes_gt?: Int;
  summaryWakeMinutes_gte?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes_not?: Int;
  summaryWakeThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryWakeThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryWakeThirtyDayAvgMinutes_lt?: Int;
  summaryWakeThirtyDayAvgMinutes_lte?: Int;
  summaryWakeThirtyDayAvgMinutes_gt?: Int;
  summaryWakeThirtyDayAvgMinutes_gte?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepCount_not?: Int;
  summaryAsleepCount_in?: Int[] | Int;
  summaryAsleepCount_not_in?: Int[] | Int;
  summaryAsleepCount_lt?: Int;
  summaryAsleepCount_lte?: Int;
  summaryAsleepCount_gt?: Int;
  summaryAsleepCount_gte?: Int;
  summaryAsleepMinutes?: Int;
  summaryAsleepMinutes_not?: Int;
  summaryAsleepMinutes_in?: Int[] | Int;
  summaryAsleepMinutes_not_in?: Int[] | Int;
  summaryAsleepMinutes_lt?: Int;
  summaryAsleepMinutes_lte?: Int;
  summaryAsleepMinutes_gt?: Int;
  summaryAsleepMinutes_gte?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeCount_not?: Int;
  summaryAwakeCount_in?: Int[] | Int;
  summaryAwakeCount_not_in?: Int[] | Int;
  summaryAwakeCount_lt?: Int;
  summaryAwakeCount_lte?: Int;
  summaryAwakeCount_gt?: Int;
  summaryAwakeCount_gte?: Int;
  summaryAwakeMinutes?: Int;
  summaryAwakeMinutes_not?: Int;
  summaryAwakeMinutes_in?: Int[] | Int;
  summaryAwakeMinutes_not_in?: Int[] | Int;
  summaryAwakeMinutes_lt?: Int;
  summaryAwakeMinutes_lte?: Int;
  summaryAwakeMinutes_gt?: Int;
  summaryAwakeMinutes_gte?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessCount_not?: Int;
  summaryRestlessCount_in?: Int[] | Int;
  summaryRestlessCount_not_in?: Int[] | Int;
  summaryRestlessCount_lt?: Int;
  summaryRestlessCount_lte?: Int;
  summaryRestlessCount_gt?: Int;
  summaryRestlessCount_gte?: Int;
  summaryRestlessMinutes?: Int;
  summaryRestlessMinutes_not?: Int;
  summaryRestlessMinutes_in?: Int[] | Int;
  summaryRestlessMinutes_not_in?: Int[] | Int;
  summaryRestlessMinutes_lt?: Int;
  summaryRestlessMinutes_lte?: Int;
  summaryRestlessMinutes_gt?: Int;
  summaryRestlessMinutes_gte?: Int;
  AND?: SleepLogWhereInput[] | SleepLogWhereInput;
  OR?: SleepLogWhereInput[] | SleepLogWhereInput;
  NOT?: SleepLogWhereInput[] | SleepLogWhereInput;
}

export interface HeartLogUpdateInput {
  dateTime?: DateTimeInput;
  caloriesOutOfRange?: Int;
  minutesOutOfRange?: Int;
  maxValueOutOfRange?: Int;
  minValueOutOfRange?: Int;
  caloriesFatBurn?: Int;
  minutesFatBurn?: Int;
  maxValueFatBurn?: Int;
  minValueFatBurn?: Int;
  caloriesCardio?: Int;
  minutesCardio?: Int;
  maxValueCardio?: Int;
  minValueCardio?: Int;
  caloriesPeak?: Int;
  minutesPeak?: Int;
  maxValuePeak?: Int;
  minValuePeak?: Int;
  intradayData?: HeartDataUpdateManyInput;
}

export interface CalorieDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  calorieLogId?: ID_Input;
  calorieLogId_not?: ID_Input;
  calorieLogId_in?: ID_Input[] | ID_Input;
  calorieLogId_not_in?: ID_Input[] | ID_Input;
  calorieLogId_lt?: ID_Input;
  calorieLogId_lte?: ID_Input;
  calorieLogId_gt?: ID_Input;
  calorieLogId_gte?: ID_Input;
  calorieLogId_contains?: ID_Input;
  calorieLogId_not_contains?: ID_Input;
  calorieLogId_starts_with?: ID_Input;
  calorieLogId_not_starts_with?: ID_Input;
  calorieLogId_ends_with?: ID_Input;
  calorieLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  calories?: Float;
  calories_not?: Float;
  calories_in?: Float[] | Float;
  calories_not_in?: Float[] | Float;
  calories_lt?: Float;
  calories_lte?: Float;
  calories_gt?: Float;
  calories_gte?: Float;
  AND?: CalorieDataWhereInput[] | CalorieDataWhereInput;
  OR?: CalorieDataWhereInput[] | CalorieDataWhereInput;
  NOT?: CalorieDataWhereInput[] | CalorieDataWhereInput;
}

export interface HeartDataUpdateManyInput {
  create?: HeartDataCreateInput[] | HeartDataCreateInput;
  update?:
    | HeartDataUpdateWithWhereUniqueNestedInput[]
    | HeartDataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | HeartDataUpsertWithWhereUniqueNestedInput[]
    | HeartDataUpsertWithWhereUniqueNestedInput;
  delete?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
  connect?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
  disconnect?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
  deleteMany?: HeartDataScalarWhereInput[] | HeartDataScalarWhereInput;
  updateMany?:
    | HeartDataUpdateManyWithWhereNestedInput[]
    | HeartDataUpdateManyWithWhereNestedInput;
}

export type DistanceLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HeartDataUpdateWithWhereUniqueNestedInput {
  where: HeartDataWhereUniqueInput;
  data: HeartDataUpdateDataInput;
}

export interface GoogleFitAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  refreshToken?: String;
  refreshToken_not?: String;
  refreshToken_in?: String[] | String;
  refreshToken_not_in?: String[] | String;
  refreshToken_lt?: String;
  refreshToken_lte?: String;
  refreshToken_gt?: String;
  refreshToken_gte?: String;
  refreshToken_contains?: String;
  refreshToken_not_contains?: String;
  refreshToken_starts_with?: String;
  refreshToken_not_starts_with?: String;
  refreshToken_ends_with?: String;
  refreshToken_not_ends_with?: String;
  accessToken?: String;
  accessToken_not?: String;
  accessToken_in?: String[] | String;
  accessToken_not_in?: String[] | String;
  accessToken_lt?: String;
  accessToken_lte?: String;
  accessToken_gt?: String;
  accessToken_gte?: String;
  accessToken_contains?: String;
  accessToken_not_contains?: String;
  accessToken_starts_with?: String;
  accessToken_not_starts_with?: String;
  accessToken_ends_with?: String;
  accessToken_not_ends_with?: String;
  expiration?: DateTimeInput;
  expiration_not?: DateTimeInput;
  expiration_in?: DateTimeInput[] | DateTimeInput;
  expiration_not_in?: DateTimeInput[] | DateTimeInput;
  expiration_lt?: DateTimeInput;
  expiration_lte?: DateTimeInput;
  expiration_gt?: DateTimeInput;
  expiration_gte?: DateTimeInput;
  AND?: GoogleFitAccountWhereInput[] | GoogleFitAccountWhereInput;
  OR?: GoogleFitAccountWhereInput[] | GoogleFitAccountWhereInput;
  NOT?: GoogleFitAccountWhereInput[] | GoogleFitAccountWhereInput;
}

export interface HeartDataUpdateDataInput {
  heartLogId?: ID_Input;
  dateTime?: DateTimeInput;
  heartRate?: Float;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneInput;
  fitbitAccount?: FitbitAccountUpdateOneInput;
  sleepLogs?: SleepLogUpdateManyInput;
}

export interface HeartDataUpsertWithWhereUniqueNestedInput {
  where: HeartDataWhereUniqueInput;
  update: HeartDataUpdateDataInput;
  create: HeartDataCreateInput;
}

export interface StepDataUpdateManyInput {
  create?: StepDataCreateInput[] | StepDataCreateInput;
  update?:
    | StepDataUpdateWithWhereUniqueNestedInput[]
    | StepDataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StepDataUpsertWithWhereUniqueNestedInput[]
    | StepDataUpsertWithWhereUniqueNestedInput;
  delete?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
  connect?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
  disconnect?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
  deleteMany?: StepDataScalarWhereInput[] | StepDataScalarWhereInput;
  updateMany?:
    | StepDataUpdateManyWithWhereNestedInput[]
    | StepDataUpdateManyWithWhereNestedInput;
}

export interface HeartLogUpdateManyMutationInput {
  dateTime?: DateTimeInput;
  caloriesOutOfRange?: Int;
  minutesOutOfRange?: Int;
  maxValueOutOfRange?: Int;
  minValueOutOfRange?: Int;
  caloriesFatBurn?: Int;
  minutesFatBurn?: Int;
  maxValueFatBurn?: Int;
  minValueFatBurn?: Int;
  caloriesCardio?: Int;
  minutesCardio?: Int;
  maxValueCardio?: Int;
  minValueCardio?: Int;
  caloriesPeak?: Int;
  minutesPeak?: Int;
  maxValuePeak?: Int;
  minValuePeak?: Int;
}

export interface HeartDataUpdateManyDataInput {
  heartLogId?: ID_Input;
  dateTime?: DateTimeInput;
  heartRate?: Float;
}

export interface HeartDataUpdateManyWithWhereNestedInput {
  where: HeartDataScalarWhereInput;
  data: HeartDataUpdateManyDataInput;
}

export interface HeartDataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  heartLogId?: ID_Input;
  heartLogId_not?: ID_Input;
  heartLogId_in?: ID_Input[] | ID_Input;
  heartLogId_not_in?: ID_Input[] | ID_Input;
  heartLogId_lt?: ID_Input;
  heartLogId_lte?: ID_Input;
  heartLogId_gt?: ID_Input;
  heartLogId_gte?: ID_Input;
  heartLogId_contains?: ID_Input;
  heartLogId_not_contains?: ID_Input;
  heartLogId_starts_with?: ID_Input;
  heartLogId_not_starts_with?: ID_Input;
  heartLogId_ends_with?: ID_Input;
  heartLogId_not_ends_with?: ID_Input;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  heartRate?: Float;
  heartRate_not?: Float;
  heartRate_in?: Float[] | Float;
  heartRate_not_in?: Float[] | Float;
  heartRate_lt?: Float;
  heartRate_lte?: Float;
  heartRate_gt?: Float;
  heartRate_gte?: Float;
  AND?: HeartDataScalarWhereInput[] | HeartDataScalarWhereInput;
  OR?: HeartDataScalarWhereInput[] | HeartDataScalarWhereInput;
  NOT?: HeartDataScalarWhereInput[] | HeartDataScalarWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface StepDataUpdateManyDataInput {
  stepLogId?: ID_Input;
  dateTime?: DateTimeInput;
  steps?: Int;
}

export interface FitbitAccountUpsertNestedInput {
  update: FitbitAccountUpdateDataInput;
  create: FitbitAccountCreateInput;
}

export interface DistanceDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DistanceDataWhereInput;
  AND?:
    | DistanceDataSubscriptionWhereInput[]
    | DistanceDataSubscriptionWhereInput;
  OR?:
    | DistanceDataSubscriptionWhereInput[]
    | DistanceDataSubscriptionWhereInput;
  NOT?:
    | DistanceDataSubscriptionWhereInput[]
    | DistanceDataSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GoogleFitAccount {
  id: ID_Output;
  userId: ID_Output;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface GoogleFitAccountPromise
  extends Promise<GoogleFitAccount>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<ID_Output>;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface GoogleFitAccountSubscription
  extends Promise<AsyncIterator<GoogleFitAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CalorieLogConnection {}

export interface CalorieLogConnectionPromise
  extends Promise<CalorieLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CalorieLogEdge>>() => T;
  aggregate: <T = AggregateCalorieLogPromise>() => T;
}

export interface CalorieLogConnectionSubscription
  extends Promise<AsyncIterator<CalorieLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CalorieLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCalorieLogSubscription>() => T;
}

export interface AggregateFitbitAccount {
  count: Int;
}

export interface AggregateFitbitAccountPromise
  extends Promise<AggregateFitbitAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFitbitAccountSubscription
  extends Promise<AsyncIterator<AggregateFitbitAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieLogEdge {
  cursor: String;
}

export interface CalorieLogEdgePromise
  extends Promise<CalorieLogEdge>,
    Fragmentable {
  node: <T = CalorieLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CalorieLogEdgeSubscription
  extends Promise<AsyncIterator<CalorieLogEdge>>,
    Fragmentable {
  node: <T = CalorieLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FitbitAccountEdge {
  cursor: String;
}

export interface FitbitAccountEdgePromise
  extends Promise<FitbitAccountEdge>,
    Fragmentable {
  node: <T = FitbitAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FitbitAccountEdgeSubscription
  extends Promise<AsyncIterator<FitbitAccountEdge>>,
    Fragmentable {
  node: <T = FitbitAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface FitbitAccountConnection {}

export interface FitbitAccountConnectionPromise
  extends Promise<FitbitAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FitbitAccountEdge>>() => T;
  aggregate: <T = AggregateFitbitAccountPromise>() => T;
}

export interface FitbitAccountConnectionSubscription
  extends Promise<AsyncIterator<FitbitAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FitbitAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFitbitAccountSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DistanceData {
  id: ID_Output;
  distanceLogId: ID_Output;
  dateTime: DateTimeOutput;
  distance: Float;
}

export interface DistanceDataPromise
  extends Promise<DistanceData>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  distanceLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  distance: () => Promise<Float>;
}

export interface DistanceDataSubscription
  extends Promise<AsyncIterator<DistanceData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  distanceLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  distance: () => Promise<AsyncIterator<Float>>;
}

export interface StepDataPreviousValues {
  id: ID_Output;
  stepLogId: ID_Output;
  dateTime: DateTimeOutput;
  steps: Int;
}

export interface StepDataPreviousValuesPromise
  extends Promise<StepDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stepLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  steps: () => Promise<Int>;
}

export interface StepDataPreviousValuesSubscription
  extends Promise<AsyncIterator<StepDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stepLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  steps: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieData {
  id: ID_Output;
  calorieLogId: ID_Output;
  dateTime: DateTimeOutput;
  calories: Float;
}

export interface CalorieDataPromise extends Promise<CalorieData>, Fragmentable {
  id: () => Promise<ID_Output>;
  calorieLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  calories: () => Promise<Float>;
}

export interface CalorieDataSubscription
  extends Promise<AsyncIterator<CalorieData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  calorieLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  calories: () => Promise<AsyncIterator<Float>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface StepLogEdge {
  cursor: String;
}

export interface StepLogEdgePromise extends Promise<StepLogEdge>, Fragmentable {
  node: <T = StepLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StepLogEdgeSubscription
  extends Promise<AsyncIterator<StepLogEdge>>,
    Fragmentable {
  node: <T = StepLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  googleFitAccount: <T = GoogleFitAccountPromise>() => T;
  fitbitAccount: <T = FitbitAccountPromise>() => T;
  sleepLogs: <T = FragmentableArray<SleepLog>>(
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  googleFitAccount: <T = GoogleFitAccountSubscription>() => T;
  fitbitAccount: <T = FitbitAccountSubscription>() => T;
  sleepLogs: <T = Promise<AsyncIterator<SleepLogSubscription>>>(
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CalorieDataSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CalorieDataSubscriptionPayloadPromise
  extends Promise<CalorieDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CalorieDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CalorieDataPreviousValuesPromise>() => T;
}

export interface CalorieDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CalorieDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CalorieDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CalorieDataPreviousValuesSubscription>() => T;
}

export interface AggregateStepData {
  count: Int;
}

export interface AggregateStepDataPromise
  extends Promise<AggregateStepData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepDataSubscription
  extends Promise<AsyncIterator<AggregateStepData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieDataPreviousValues {
  id: ID_Output;
  calorieLogId: ID_Output;
  dateTime: DateTimeOutput;
  calories: Float;
}

export interface CalorieDataPreviousValuesPromise
  extends Promise<CalorieDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  calorieLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  calories: () => Promise<Float>;
}

export interface CalorieDataPreviousValuesSubscription
  extends Promise<AsyncIterator<CalorieDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  calorieLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  calories: () => Promise<AsyncIterator<Float>>;
}

export interface StepDataConnection {}

export interface StepDataConnectionPromise
  extends Promise<StepDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StepDataEdge>>() => T;
  aggregate: <T = AggregateStepDataPromise>() => T;
}

export interface StepDataConnectionSubscription
  extends Promise<AsyncIterator<StepDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepDataSubscription>() => T;
}

export interface CalorieDataEdge {
  cursor: String;
}

export interface CalorieDataEdgePromise
  extends Promise<CalorieDataEdge>,
    Fragmentable {
  node: <T = CalorieDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CalorieDataEdgeSubscription
  extends Promise<AsyncIterator<CalorieDataEdge>>,
    Fragmentable {
  node: <T = CalorieDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSleepLog {
  count: Int;
}

export interface AggregateSleepLogPromise
  extends Promise<AggregateSleepLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSleepLogSubscription
  extends Promise<AsyncIterator<AggregateSleepLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieLogSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CalorieLogSubscriptionPayloadPromise
  extends Promise<CalorieLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CalorieLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CalorieLogPreviousValuesPromise>() => T;
}

export interface CalorieLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CalorieLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CalorieLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CalorieLogPreviousValuesSubscription>() => T;
}

export interface SleepLogConnection {}

export interface SleepLogConnectionPromise
  extends Promise<SleepLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SleepLogEdge>>() => T;
  aggregate: <T = AggregateSleepLogPromise>() => T;
}

export interface SleepLogConnectionSubscription
  extends Promise<AsyncIterator<SleepLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SleepLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSleepLogSubscription>() => T;
}

export interface CalorieLogPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  totalCalories: Float;
}

export interface CalorieLogPreviousValuesPromise
  extends Promise<CalorieLogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalCalories: () => Promise<Float>;
}

export interface CalorieLogPreviousValuesSubscription
  extends Promise<AsyncIterator<CalorieLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalCalories: () => Promise<AsyncIterator<Float>>;
}

export interface SleepLog {
  id: ID_Output;
  userId: ID_Output;
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeOutput;
  timeInBed: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepLogPromise extends Promise<SleepLog>, Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<ID_Output>;
  dateOfSleep: () => Promise<String>;
  duration: () => Promise<Int>;
  efficiency: () => Promise<Int>;
  isMainSleep: () => Promise<Boolean>;
  logId: () => Promise<Float>;
  minutesAfterWakeup: () => Promise<Int>;
  minutesAsleep: () => Promise<Int>;
  minutesAwake: () => Promise<Int>;
  minutesToFallAsleep: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  timeInBed: () => Promise<Int>;
  type: () => Promise<String>;
  data: <T = FragmentableArray<SleepData>>(
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  summaryDeepCount: () => Promise<Int>;
  summaryDeepMinutes: () => Promise<Int>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<Int>;
  summaryLightCount: () => Promise<Int>;
  summaryLightMinutes: () => Promise<Int>;
  summaryLightThirtyDayAvgMinutes: () => Promise<Int>;
  summaryRemCount: () => Promise<Int>;
  summaryRemMinutes: () => Promise<Int>;
  summaryRemThirtyDayAvgMinutes: () => Promise<Int>;
  summaryWakeCount: () => Promise<Int>;
  summaryWakeMinutes: () => Promise<Int>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<Int>;
  summaryAsleepCount: () => Promise<Int>;
  summaryAsleepMinutes: () => Promise<Int>;
  summaryAwakeCount: () => Promise<Int>;
  summaryAwakeMinutes: () => Promise<Int>;
  summaryRestlessCount: () => Promise<Int>;
  summaryRestlessMinutes: () => Promise<Int>;
}

export interface SleepLogSubscription
  extends Promise<AsyncIterator<SleepLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  dateOfSleep: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  efficiency: () => Promise<AsyncIterator<Int>>;
  isMainSleep: () => Promise<AsyncIterator<Boolean>>;
  logId: () => Promise<AsyncIterator<Float>>;
  minutesAfterWakeup: () => Promise<AsyncIterator<Int>>;
  minutesAsleep: () => Promise<AsyncIterator<Int>>;
  minutesAwake: () => Promise<AsyncIterator<Int>>;
  minutesToFallAsleep: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  timeInBed: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  data: <T = Promise<AsyncIterator<SleepDataSubscription>>>(
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  summaryDeepCount: () => Promise<AsyncIterator<Int>>;
  summaryDeepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightCount: () => Promise<AsyncIterator<Int>>;
  summaryLightMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemCount: () => Promise<AsyncIterator<Int>>;
  summaryRemMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeCount: () => Promise<AsyncIterator<Int>>;
  summaryWakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAsleepCount: () => Promise<AsyncIterator<Int>>;
  summaryAsleepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAwakeCount: () => Promise<AsyncIterator<Int>>;
  summaryAwakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRestlessCount: () => Promise<AsyncIterator<Int>>;
  summaryRestlessMinutes: () => Promise<AsyncIterator<Int>>;
}

export interface FitbitAccount {
  id: ID_Output;
  userId: ID_Output;
  fitbitUserId: String;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface FitbitAccountPromise
  extends Promise<FitbitAccount>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<ID_Output>;
  fitbitUserId: () => Promise<String>;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface FitbitAccountSubscription
  extends Promise<AsyncIterator<FitbitAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  fitbitUserId: () => Promise<AsyncIterator<String>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SleepDataEdge {
  cursor: String;
}

export interface SleepDataEdgePromise
  extends Promise<SleepDataEdge>,
    Fragmentable {
  node: <T = SleepDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SleepDataEdgeSubscription
  extends Promise<AsyncIterator<SleepDataEdge>>,
    Fragmentable {
  node: <T = SleepDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DistanceDataSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DistanceDataSubscriptionPayloadPromise
  extends Promise<DistanceDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DistanceDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DistanceDataPreviousValuesPromise>() => T;
}

export interface DistanceDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DistanceDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DistanceDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DistanceDataPreviousValuesSubscription>() => T;
}

export interface StepLogPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  totalSteps: Int;
}

export interface StepLogPreviousValuesPromise
  extends Promise<StepLogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalSteps: () => Promise<Int>;
}

export interface StepLogPreviousValuesSubscription
  extends Promise<AsyncIterator<StepLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalSteps: () => Promise<AsyncIterator<Int>>;
}

export interface DistanceDataPreviousValues {
  id: ID_Output;
  distanceLogId: ID_Output;
  dateTime: DateTimeOutput;
  distance: Float;
}

export interface DistanceDataPreviousValuesPromise
  extends Promise<DistanceDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  distanceLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  distance: () => Promise<Float>;
}

export interface DistanceDataPreviousValuesSubscription
  extends Promise<AsyncIterator<DistanceDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  distanceLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  distance: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateHeartLog {
  count: Int;
}

export interface AggregateHeartLogPromise
  extends Promise<AggregateHeartLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeartLogSubscription
  extends Promise<AsyncIterator<AggregateHeartLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateDistanceLog {
  count: Int;
}

export interface AggregateDistanceLogPromise
  extends Promise<AggregateDistanceLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDistanceLogSubscription
  extends Promise<AsyncIterator<AggregateDistanceLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HeartLogConnection {}

export interface HeartLogConnectionPromise
  extends Promise<HeartLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HeartLogEdge>>() => T;
  aggregate: <T = AggregateHeartLogPromise>() => T;
}

export interface HeartLogConnectionSubscription
  extends Promise<AsyncIterator<HeartLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeartLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeartLogSubscription>() => T;
}

export interface DistanceLogSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DistanceLogSubscriptionPayloadPromise
  extends Promise<DistanceLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DistanceLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DistanceLogPreviousValuesPromise>() => T;
}

export interface DistanceLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DistanceLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DistanceLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DistanceLogPreviousValuesSubscription>() => T;
}

export interface HeartLog {
  id: ID_Output;
  dateTime: DateTimeOutput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
}

export interface HeartLogPromise extends Promise<HeartLog>, Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  caloriesOutOfRange: () => Promise<Int>;
  minutesOutOfRange: () => Promise<Int>;
  maxValueOutOfRange: () => Promise<Int>;
  minValueOutOfRange: () => Promise<Int>;
  caloriesFatBurn: () => Promise<Int>;
  minutesFatBurn: () => Promise<Int>;
  maxValueFatBurn: () => Promise<Int>;
  minValueFatBurn: () => Promise<Int>;
  caloriesCardio: () => Promise<Int>;
  minutesCardio: () => Promise<Int>;
  maxValueCardio: () => Promise<Int>;
  minValueCardio: () => Promise<Int>;
  caloriesPeak: () => Promise<Int>;
  minutesPeak: () => Promise<Int>;
  maxValuePeak: () => Promise<Int>;
  minValuePeak: () => Promise<Int>;
  intradayData: <T = FragmentableArray<HeartData>>(
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HeartLogSubscription
  extends Promise<AsyncIterator<HeartLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  caloriesOutOfRange: () => Promise<AsyncIterator<Int>>;
  minutesOutOfRange: () => Promise<AsyncIterator<Int>>;
  maxValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  minValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  caloriesFatBurn: () => Promise<AsyncIterator<Int>>;
  minutesFatBurn: () => Promise<AsyncIterator<Int>>;
  maxValueFatBurn: () => Promise<AsyncIterator<Int>>;
  minValueFatBurn: () => Promise<AsyncIterator<Int>>;
  caloriesCardio: () => Promise<AsyncIterator<Int>>;
  minutesCardio: () => Promise<AsyncIterator<Int>>;
  maxValueCardio: () => Promise<AsyncIterator<Int>>;
  minValueCardio: () => Promise<AsyncIterator<Int>>;
  caloriesPeak: () => Promise<AsyncIterator<Int>>;
  minutesPeak: () => Promise<AsyncIterator<Int>>;
  maxValuePeak: () => Promise<AsyncIterator<Int>>;
  minValuePeak: () => Promise<AsyncIterator<Int>>;
  intradayData: <T = Promise<AsyncIterator<HeartDataSubscription>>>(
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DistanceLogPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  totalDistance: Float;
}

export interface DistanceLogPreviousValuesPromise
  extends Promise<DistanceLogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalDistance: () => Promise<Float>;
}

export interface DistanceLogPreviousValuesSubscription
  extends Promise<AsyncIterator<DistanceLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalDistance: () => Promise<AsyncIterator<Float>>;
}

export interface HeartDataEdge {
  cursor: String;
}

export interface HeartDataEdgePromise
  extends Promise<HeartDataEdge>,
    Fragmentable {
  node: <T = HeartDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HeartDataEdgeSubscription
  extends Promise<AsyncIterator<HeartDataEdge>>,
    Fragmentable {
  node: <T = HeartDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DistanceLogEdge {
  cursor: String;
}

export interface DistanceLogEdgePromise
  extends Promise<DistanceLogEdge>,
    Fragmentable {
  node: <T = DistanceLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DistanceLogEdgeSubscription
  extends Promise<AsyncIterator<DistanceLogEdge>>,
    Fragmentable {
  node: <T = DistanceLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface FitbitAccountSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FitbitAccountSubscriptionPayloadPromise
  extends Promise<FitbitAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FitbitAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FitbitAccountPreviousValuesPromise>() => T;
}

export interface FitbitAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FitbitAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FitbitAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FitbitAccountPreviousValuesSubscription>() => T;
}

export interface AggregateGoogleFitAccount {
  count: Int;
}

export interface AggregateGoogleFitAccountPromise
  extends Promise<AggregateGoogleFitAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGoogleFitAccountSubscription
  extends Promise<AsyncIterator<AggregateGoogleFitAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FitbitAccountPreviousValues {
  id: ID_Output;
  userId: ID_Output;
  fitbitUserId: String;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface FitbitAccountPreviousValuesPromise
  extends Promise<FitbitAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<ID_Output>;
  fitbitUserId: () => Promise<String>;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface FitbitAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<FitbitAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  fitbitUserId: () => Promise<AsyncIterator<String>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GoogleFitAccountConnection {}

export interface GoogleFitAccountConnectionPromise
  extends Promise<GoogleFitAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GoogleFitAccountEdge>>() => T;
  aggregate: <T = AggregateGoogleFitAccountPromise>() => T;
}

export interface GoogleFitAccountConnectionSubscription
  extends Promise<AsyncIterator<GoogleFitAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GoogleFitAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGoogleFitAccountSubscription>() => T;
}

export interface DistanceLogConnection {}

export interface DistanceLogConnectionPromise
  extends Promise<DistanceLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DistanceLogEdge>>() => T;
  aggregate: <T = AggregateDistanceLogPromise>() => T;
}

export interface DistanceLogConnectionSubscription
  extends Promise<AsyncIterator<DistanceLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DistanceLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDistanceLogSubscription>() => T;
}

export interface CalorieLog {
  id: ID_Output;
  date: DateTimeOutput;
  totalCalories: Float;
}

export interface CalorieLogPromise extends Promise<CalorieLog>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalCalories: () => Promise<Float>;
  intradayData: <T = FragmentableArray<CalorieData>>(
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CalorieLogSubscription
  extends Promise<AsyncIterator<CalorieLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalCalories: () => Promise<AsyncIterator<Float>>;
  intradayData: <T = Promise<AsyncIterator<CalorieDataSubscription>>>(
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GoogleFitAccountSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GoogleFitAccountSubscriptionPayloadPromise
  extends Promise<GoogleFitAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GoogleFitAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GoogleFitAccountPreviousValuesPromise>() => T;
}

export interface GoogleFitAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GoogleFitAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GoogleFitAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GoogleFitAccountPreviousValuesSubscription>() => T;
}

export interface StepLogConnection {}

export interface StepLogConnectionPromise
  extends Promise<StepLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StepLogEdge>>() => T;
  aggregate: <T = AggregateStepLogPromise>() => T;
}

export interface StepLogConnectionSubscription
  extends Promise<AsyncIterator<StepLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepLogSubscription>() => T;
}

export interface GoogleFitAccountPreviousValues {
  id: ID_Output;
  userId: ID_Output;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface GoogleFitAccountPreviousValuesPromise
  extends Promise<GoogleFitAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<ID_Output>;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface GoogleFitAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<GoogleFitAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StepDataEdge {
  cursor: String;
}

export interface StepDataEdgePromise
  extends Promise<StepDataEdge>,
    Fragmentable {
  node: <T = StepDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StepDataEdgeSubscription
  extends Promise<AsyncIterator<StepDataEdge>>,
    Fragmentable {
  node: <T = StepDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCalorieData {
  count: Int;
}

export interface AggregateCalorieDataPromise
  extends Promise<AggregateCalorieData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCalorieDataSubscription
  extends Promise<AsyncIterator<AggregateCalorieData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SleepLogEdge {
  cursor: String;
}

export interface SleepLogEdgePromise
  extends Promise<SleepLogEdge>,
    Fragmentable {
  node: <T = SleepLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SleepLogEdgeSubscription
  extends Promise<AsyncIterator<SleepLogEdge>>,
    Fragmentable {
  node: <T = SleepLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HeartDataSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HeartDataSubscriptionPayloadPromise
  extends Promise<HeartDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeartDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HeartDataPreviousValuesPromise>() => T;
}

export interface HeartDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeartDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeartDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HeartDataPreviousValuesSubscription>() => T;
}

export interface AggregateSleepData {
  count: Int;
}

export interface AggregateSleepDataPromise
  extends Promise<AggregateSleepData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSleepDataSubscription
  extends Promise<AsyncIterator<AggregateSleepData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HeartDataPreviousValues {
  id: ID_Output;
  heartLogId: ID_Output;
  dateTime: DateTimeOutput;
  heartRate: Float;
}

export interface HeartDataPreviousValuesPromise
  extends Promise<HeartDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  heartLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  heartRate: () => Promise<Float>;
}

export interface HeartDataPreviousValuesSubscription
  extends Promise<AsyncIterator<HeartDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  heartLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  heartRate: () => Promise<AsyncIterator<Float>>;
}

export interface SleepData {
  id: ID_Output;
  sleepLogId: ID_Output;
  dateTime: DateTimeOutput;
  level: String;
  second: Int;
}

export interface SleepDataPromise extends Promise<SleepData>, Fragmentable {
  id: () => Promise<ID_Output>;
  sleepLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  level: () => Promise<String>;
  second: () => Promise<Int>;
}

export interface SleepDataSubscription
  extends Promise<AsyncIterator<SleepData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sleepLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  level: () => Promise<AsyncIterator<String>>;
  second: () => Promise<AsyncIterator<Int>>;
}

export interface DistanceLog {
  id: ID_Output;
  date: DateTimeOutput;
  totalDistance: Float;
}

export interface DistanceLogPromise extends Promise<DistanceLog>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalDistance: () => Promise<Float>;
  intradayData: <T = FragmentableArray<DistanceData>>(
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DistanceLogSubscription
  extends Promise<AsyncIterator<DistanceLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalDistance: () => Promise<AsyncIterator<Float>>;
  intradayData: <T = Promise<AsyncIterator<DistanceDataSubscription>>>(
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CalorieDataConnection {}

export interface CalorieDataConnectionPromise
  extends Promise<CalorieDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CalorieDataEdge>>() => T;
  aggregate: <T = AggregateCalorieDataPromise>() => T;
}

export interface CalorieDataConnectionSubscription
  extends Promise<AsyncIterator<CalorieDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CalorieDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCalorieDataSubscription>() => T;
}

export interface HeartLogSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HeartLogSubscriptionPayloadPromise
  extends Promise<HeartLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeartLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HeartLogPreviousValuesPromise>() => T;
}

export interface HeartLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeartLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeartLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HeartLogPreviousValuesSubscription>() => T;
}

export interface HeartDataConnection {}

export interface HeartDataConnectionPromise
  extends Promise<HeartDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HeartDataEdge>>() => T;
  aggregate: <T = AggregateHeartDataPromise>() => T;
}

export interface HeartDataConnectionSubscription
  extends Promise<AsyncIterator<HeartDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeartDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeartDataSubscription>() => T;
}

export interface HeartLogPreviousValues {
  id: ID_Output;
  dateTime: DateTimeOutput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
}

export interface HeartLogPreviousValuesPromise
  extends Promise<HeartLogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  caloriesOutOfRange: () => Promise<Int>;
  minutesOutOfRange: () => Promise<Int>;
  maxValueOutOfRange: () => Promise<Int>;
  minValueOutOfRange: () => Promise<Int>;
  caloriesFatBurn: () => Promise<Int>;
  minutesFatBurn: () => Promise<Int>;
  maxValueFatBurn: () => Promise<Int>;
  minValueFatBurn: () => Promise<Int>;
  caloriesCardio: () => Promise<Int>;
  minutesCardio: () => Promise<Int>;
  maxValueCardio: () => Promise<Int>;
  minValueCardio: () => Promise<Int>;
  caloriesPeak: () => Promise<Int>;
  minutesPeak: () => Promise<Int>;
  maxValuePeak: () => Promise<Int>;
  minValuePeak: () => Promise<Int>;
}

export interface HeartLogPreviousValuesSubscription
  extends Promise<AsyncIterator<HeartLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  caloriesOutOfRange: () => Promise<AsyncIterator<Int>>;
  minutesOutOfRange: () => Promise<AsyncIterator<Int>>;
  maxValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  minValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  caloriesFatBurn: () => Promise<AsyncIterator<Int>>;
  minutesFatBurn: () => Promise<AsyncIterator<Int>>;
  maxValueFatBurn: () => Promise<AsyncIterator<Int>>;
  minValueFatBurn: () => Promise<AsyncIterator<Int>>;
  caloriesCardio: () => Promise<AsyncIterator<Int>>;
  minutesCardio: () => Promise<AsyncIterator<Int>>;
  maxValueCardio: () => Promise<AsyncIterator<Int>>;
  minValueCardio: () => Promise<AsyncIterator<Int>>;
  caloriesPeak: () => Promise<AsyncIterator<Int>>;
  minutesPeak: () => Promise<AsyncIterator<Int>>;
  maxValuePeak: () => Promise<AsyncIterator<Int>>;
  minValuePeak: () => Promise<AsyncIterator<Int>>;
}

export interface GoogleFitAccountEdge {
  cursor: String;
}

export interface GoogleFitAccountEdgePromise
  extends Promise<GoogleFitAccountEdge>,
    Fragmentable {
  node: <T = GoogleFitAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GoogleFitAccountEdgeSubscription
  extends Promise<AsyncIterator<GoogleFitAccountEdge>>,
    Fragmentable {
  node: <T = GoogleFitAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDistanceData {
  count: Int;
}

export interface AggregateDistanceDataPromise
  extends Promise<AggregateDistanceData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDistanceDataSubscription
  extends Promise<AsyncIterator<AggregateDistanceData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateStepLog {
  count: Int;
}

export interface AggregateStepLogPromise
  extends Promise<AggregateStepLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepLogSubscription
  extends Promise<AsyncIterator<AggregateStepLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SleepDataSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SleepDataSubscriptionPayloadPromise
  extends Promise<SleepDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SleepDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SleepDataPreviousValuesPromise>() => T;
}

export interface SleepDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SleepDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SleepDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SleepDataPreviousValuesSubscription>() => T;
}

export interface StepData {
  id: ID_Output;
  stepLogId: ID_Output;
  dateTime: DateTimeOutput;
  steps: Int;
}

export interface StepDataPromise extends Promise<StepData>, Fragmentable {
  id: () => Promise<ID_Output>;
  stepLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  steps: () => Promise<Int>;
}

export interface StepDataSubscription
  extends Promise<AsyncIterator<StepData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stepLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  steps: () => Promise<AsyncIterator<Int>>;
}

export interface SleepDataPreviousValues {
  id: ID_Output;
  sleepLogId: ID_Output;
  dateTime: DateTimeOutput;
  level: String;
  second: Int;
}

export interface SleepDataPreviousValuesPromise
  extends Promise<SleepDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sleepLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  level: () => Promise<String>;
  second: () => Promise<Int>;
}

export interface SleepDataPreviousValuesSubscription
  extends Promise<AsyncIterator<SleepDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sleepLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  level: () => Promise<AsyncIterator<String>>;
  second: () => Promise<AsyncIterator<Int>>;
}

export interface SleepDataConnection {}

export interface SleepDataConnectionPromise
  extends Promise<SleepDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SleepDataEdge>>() => T;
  aggregate: <T = AggregateSleepDataPromise>() => T;
}

export interface SleepDataConnectionSubscription
  extends Promise<AsyncIterator<SleepDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SleepDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSleepDataSubscription>() => T;
}

export interface DistanceDataEdge {
  cursor: String;
}

export interface DistanceDataEdgePromise
  extends Promise<DistanceDataEdge>,
    Fragmentable {
  node: <T = DistanceDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DistanceDataEdgeSubscription
  extends Promise<AsyncIterator<DistanceDataEdge>>,
    Fragmentable {
  node: <T = DistanceDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHeartData {
  count: Int;
}

export interface AggregateHeartDataPromise
  extends Promise<AggregateHeartData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeartDataSubscription
  extends Promise<AsyncIterator<AggregateHeartData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StepLogSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StepLogSubscriptionPayloadPromise
  extends Promise<StepLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepLogPreviousValuesPromise>() => T;
}

export interface StepLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepLogPreviousValuesSubscription>() => T;
}

export interface StepDataSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StepDataSubscriptionPayloadPromise
  extends Promise<StepDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepDataPreviousValuesPromise>() => T;
}

export interface StepDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepDataPreviousValuesSubscription>() => T;
}

export interface DistanceDataConnection {}

export interface DistanceDataConnectionPromise
  extends Promise<DistanceDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DistanceDataEdge>>() => T;
  aggregate: <T = AggregateDistanceDataPromise>() => T;
}

export interface DistanceDataConnectionSubscription
  extends Promise<AsyncIterator<DistanceDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DistanceDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDistanceDataSubscription>() => T;
}

export interface SleepLogPreviousValues {
  id: ID_Output;
  userId: ID_Output;
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeOutput;
  timeInBed: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepLogPreviousValuesPromise
  extends Promise<SleepLogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<ID_Output>;
  dateOfSleep: () => Promise<String>;
  duration: () => Promise<Int>;
  efficiency: () => Promise<Int>;
  isMainSleep: () => Promise<Boolean>;
  logId: () => Promise<Float>;
  minutesAfterWakeup: () => Promise<Int>;
  minutesAsleep: () => Promise<Int>;
  minutesAwake: () => Promise<Int>;
  minutesToFallAsleep: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  timeInBed: () => Promise<Int>;
  type: () => Promise<String>;
  summaryDeepCount: () => Promise<Int>;
  summaryDeepMinutes: () => Promise<Int>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<Int>;
  summaryLightCount: () => Promise<Int>;
  summaryLightMinutes: () => Promise<Int>;
  summaryLightThirtyDayAvgMinutes: () => Promise<Int>;
  summaryRemCount: () => Promise<Int>;
  summaryRemMinutes: () => Promise<Int>;
  summaryRemThirtyDayAvgMinutes: () => Promise<Int>;
  summaryWakeCount: () => Promise<Int>;
  summaryWakeMinutes: () => Promise<Int>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<Int>;
  summaryAsleepCount: () => Promise<Int>;
  summaryAsleepMinutes: () => Promise<Int>;
  summaryAwakeCount: () => Promise<Int>;
  summaryAwakeMinutes: () => Promise<Int>;
  summaryRestlessCount: () => Promise<Int>;
  summaryRestlessMinutes: () => Promise<Int>;
}

export interface SleepLogPreviousValuesSubscription
  extends Promise<AsyncIterator<SleepLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  dateOfSleep: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  efficiency: () => Promise<AsyncIterator<Int>>;
  isMainSleep: () => Promise<AsyncIterator<Boolean>>;
  logId: () => Promise<AsyncIterator<Float>>;
  minutesAfterWakeup: () => Promise<AsyncIterator<Int>>;
  minutesAsleep: () => Promise<AsyncIterator<Int>>;
  minutesAwake: () => Promise<AsyncIterator<Int>>;
  minutesToFallAsleep: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  timeInBed: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  summaryDeepCount: () => Promise<AsyncIterator<Int>>;
  summaryDeepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightCount: () => Promise<AsyncIterator<Int>>;
  summaryLightMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemCount: () => Promise<AsyncIterator<Int>>;
  summaryRemMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeCount: () => Promise<AsyncIterator<Int>>;
  summaryWakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAsleepCount: () => Promise<AsyncIterator<Int>>;
  summaryAsleepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAwakeCount: () => Promise<AsyncIterator<Int>>;
  summaryAwakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRestlessCount: () => Promise<AsyncIterator<Int>>;
  summaryRestlessMinutes: () => Promise<AsyncIterator<Int>>;
}

export interface SleepLogSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SleepLogSubscriptionPayloadPromise
  extends Promise<SleepLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SleepLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SleepLogPreviousValuesPromise>() => T;
}

export interface SleepLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SleepLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SleepLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SleepLogPreviousValuesSubscription>() => T;
}

export interface StepLog {
  id: ID_Output;
  date: DateTimeOutput;
  totalSteps: Int;
}

export interface StepLogPromise extends Promise<StepLog>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalSteps: () => Promise<Int>;
  intradayData: <T = FragmentableArray<StepData>>(
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StepLogSubscription
  extends Promise<AsyncIterator<StepLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalSteps: () => Promise<AsyncIterator<Int>>;
  intradayData: <T = Promise<AsyncIterator<StepDataSubscription>>>(
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HeartData {
  id: ID_Output;
  heartLogId: ID_Output;
  dateTime: DateTimeOutput;
  heartRate: Float;
}

export interface HeartDataPromise extends Promise<HeartData>, Fragmentable {
  id: () => Promise<ID_Output>;
  heartLogId: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  heartRate: () => Promise<Float>;
}

export interface HeartDataSubscription
  extends Promise<AsyncIterator<HeartData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  heartLogId: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  heartRate: () => Promise<AsyncIterator<Float>>;
}

export interface HeartLogEdge {
  cursor: String;
}

export interface HeartLogEdgePromise
  extends Promise<HeartLogEdge>,
    Fragmentable {
  node: <T = HeartLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HeartLogEdgeSubscription
  extends Promise<AsyncIterator<HeartLogEdge>>,
    Fragmentable {
  node: <T = HeartLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCalorieLog {
  count: Int;
}

export interface AggregateCalorieLogPromise
  extends Promise<AggregateCalorieLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCalorieLogSubscription
  extends Promise<AsyncIterator<AggregateCalorieLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "CalorieData",
    embedded: false
  },
  {
    name: "CalorieLog",
    embedded: false
  },
  {
    name: "DistanceData",
    embedded: false
  },
  {
    name: "DistanceLog",
    embedded: false
  },
  {
    name: "FitbitAccount",
    embedded: false
  },
  {
    name: "GoogleFitAccount",
    embedded: false
  },
  {
    name: "HeartData",
    embedded: false
  },
  {
    name: "HeartLog",
    embedded: false
  },
  {
    name: "SleepData",
    embedded: false
  },
  {
    name: "SleepLog",
    embedded: false
  },
  {
    name: "StepData",
    embedded: false
  },
  {
    name: "StepLog",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
