// Code generated by Prisma (prisma@1.19.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  calorieData: (where?: CalorieDataWhereInput) => Promise<boolean>;
  calorieLog: (where?: CalorieLogWhereInput) => Promise<boolean>;
  distanceData: (where?: DistanceDataWhereInput) => Promise<boolean>;
  distanceLog: (where?: DistanceLogWhereInput) => Promise<boolean>;
  fitbitAccount: (where?: FitbitAccountWhereInput) => Promise<boolean>;
  googleFitAccount: (where?: GoogleFitAccountWhereInput) => Promise<boolean>;
  heartData: (where?: HeartDataWhereInput) => Promise<boolean>;
  heartLog: (where?: HeartLogWhereInput) => Promise<boolean>;
  productivityData: (where?: ProductivityDataWhereInput) => Promise<boolean>;
  rescueTimeAccount: (where?: RescueTimeAccountWhereInput) => Promise<boolean>;
  sleepData: (where?: SleepDataWhereInput) => Promise<boolean>;
  sleepLog: (where?: SleepLogWhereInput) => Promise<boolean>;
  stepData: (where?: StepDataWhereInput) => Promise<boolean>;
  stepLog: (where?: StepLogWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  calorieData: (where: CalorieDataWhereUniqueInput) => CalorieData;
  calorieDatas: (
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CalorieDataNode>;
  calorieDatasConnection: (
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CalorieDataConnection;
  calorieLog: (where: CalorieLogWhereUniqueInput) => CalorieLog;
  calorieLogs: (
    args?: {
      where?: CalorieLogWhereInput;
      orderBy?: CalorieLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CalorieLogNode>;
  calorieLogsConnection: (
    args?: {
      where?: CalorieLogWhereInput;
      orderBy?: CalorieLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CalorieLogConnection;
  distanceData: (where: DistanceDataWhereUniqueInput) => DistanceData;
  distanceDatas: (
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DistanceDataNode>;
  distanceDatasConnection: (
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DistanceDataConnection;
  distanceLog: (where: DistanceLogWhereUniqueInput) => DistanceLog;
  distanceLogs: (
    args?: {
      where?: DistanceLogWhereInput;
      orderBy?: DistanceLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DistanceLogNode>;
  distanceLogsConnection: (
    args?: {
      where?: DistanceLogWhereInput;
      orderBy?: DistanceLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DistanceLogConnection;
  fitbitAccount: (where: FitbitAccountWhereUniqueInput) => FitbitAccount;
  fitbitAccounts: (
    args?: {
      where?: FitbitAccountWhereInput;
      orderBy?: FitbitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FitbitAccountNode>;
  fitbitAccountsConnection: (
    args?: {
      where?: FitbitAccountWhereInput;
      orderBy?: FitbitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FitbitAccountConnection;
  googleFitAccount: (
    where: GoogleFitAccountWhereUniqueInput
  ) => GoogleFitAccount;
  googleFitAccounts: (
    args?: {
      where?: GoogleFitAccountWhereInput;
      orderBy?: GoogleFitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GoogleFitAccountNode>;
  googleFitAccountsConnection: (
    args?: {
      where?: GoogleFitAccountWhereInput;
      orderBy?: GoogleFitAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GoogleFitAccountConnection;
  heartData: (where: HeartDataWhereUniqueInput) => HeartData;
  heartDatas: (
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HeartDataNode>;
  heartDatasConnection: (
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HeartDataConnection;
  heartLog: (where: HeartLogWhereUniqueInput) => HeartLog;
  heartLogs: (
    args?: {
      where?: HeartLogWhereInput;
      orderBy?: HeartLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HeartLogNode>;
  heartLogsConnection: (
    args?: {
      where?: HeartLogWhereInput;
      orderBy?: HeartLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HeartLogConnection;
  productivityData: (
    where: ProductivityDataWhereUniqueInput
  ) => ProductivityData;
  productivityDatas: (
    args?: {
      where?: ProductivityDataWhereInput;
      orderBy?: ProductivityDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductivityDataNode>;
  productivityDatasConnection: (
    args?: {
      where?: ProductivityDataWhereInput;
      orderBy?: ProductivityDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductivityDataConnection;
  rescueTimeAccount: (
    where: RescueTimeAccountWhereUniqueInput
  ) => RescueTimeAccount;
  rescueTimeAccounts: (
    args?: {
      where?: RescueTimeAccountWhereInput;
      orderBy?: RescueTimeAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RescueTimeAccountNode>;
  rescueTimeAccountsConnection: (
    args?: {
      where?: RescueTimeAccountWhereInput;
      orderBy?: RescueTimeAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RescueTimeAccountConnection;
  sleepData: (where: SleepDataWhereUniqueInput) => SleepData;
  sleepDatas: (
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SleepDataNode>;
  sleepDatasConnection: (
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SleepDataConnection;
  sleepLog: (where: SleepLogWhereUniqueInput) => SleepLog;
  sleepLogs: (
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SleepLogNode>;
  sleepLogsConnection: (
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SleepLogConnection;
  stepData: (where: StepDataWhereUniqueInput) => StepData;
  stepDatas: (
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<StepDataNode>;
  stepDatasConnection: (
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StepDataConnection;
  stepLog: (where: StepLogWhereUniqueInput) => StepLog;
  stepLogs: (
    args?: {
      where?: StepLogWhereInput;
      orderBy?: StepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<StepLogNode>;
  stepLogsConnection: (
    args?: {
      where?: StepLogWhereInput;
      orderBy?: StepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StepLogConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserNode>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCalorieData: (data: CalorieDataCreateInput) => CalorieData;
  updateCalorieData: (
    args: { data: CalorieDataUpdateInput; where: CalorieDataWhereUniqueInput }
  ) => CalorieData;
  updateManyCalorieDatas: (
    args: { data: CalorieDataUpdateInput; where?: CalorieDataWhereInput }
  ) => BatchPayload;
  upsertCalorieData: (
    args: {
      where: CalorieDataWhereUniqueInput;
      create: CalorieDataCreateInput;
      update: CalorieDataUpdateInput;
    }
  ) => CalorieData;
  deleteCalorieData: (where: CalorieDataWhereUniqueInput) => CalorieData;
  deleteManyCalorieDatas: (where?: CalorieDataWhereInput) => BatchPayload;
  createCalorieLog: (data: CalorieLogCreateInput) => CalorieLog;
  updateCalorieLog: (
    args: { data: CalorieLogUpdateInput; where: CalorieLogWhereUniqueInput }
  ) => CalorieLog;
  updateManyCalorieLogs: (
    args: { data: CalorieLogUpdateInput; where?: CalorieLogWhereInput }
  ) => BatchPayload;
  upsertCalorieLog: (
    args: {
      where: CalorieLogWhereUniqueInput;
      create: CalorieLogCreateInput;
      update: CalorieLogUpdateInput;
    }
  ) => CalorieLog;
  deleteCalorieLog: (where: CalorieLogWhereUniqueInput) => CalorieLog;
  deleteManyCalorieLogs: (where?: CalorieLogWhereInput) => BatchPayload;
  createDistanceData: (data: DistanceDataCreateInput) => DistanceData;
  updateDistanceData: (
    args: { data: DistanceDataUpdateInput; where: DistanceDataWhereUniqueInput }
  ) => DistanceData;
  updateManyDistanceDatas: (
    args: { data: DistanceDataUpdateInput; where?: DistanceDataWhereInput }
  ) => BatchPayload;
  upsertDistanceData: (
    args: {
      where: DistanceDataWhereUniqueInput;
      create: DistanceDataCreateInput;
      update: DistanceDataUpdateInput;
    }
  ) => DistanceData;
  deleteDistanceData: (where: DistanceDataWhereUniqueInput) => DistanceData;
  deleteManyDistanceDatas: (where?: DistanceDataWhereInput) => BatchPayload;
  createDistanceLog: (data: DistanceLogCreateInput) => DistanceLog;
  updateDistanceLog: (
    args: { data: DistanceLogUpdateInput; where: DistanceLogWhereUniqueInput }
  ) => DistanceLog;
  updateManyDistanceLogs: (
    args: { data: DistanceLogUpdateInput; where?: DistanceLogWhereInput }
  ) => BatchPayload;
  upsertDistanceLog: (
    args: {
      where: DistanceLogWhereUniqueInput;
      create: DistanceLogCreateInput;
      update: DistanceLogUpdateInput;
    }
  ) => DistanceLog;
  deleteDistanceLog: (where: DistanceLogWhereUniqueInput) => DistanceLog;
  deleteManyDistanceLogs: (where?: DistanceLogWhereInput) => BatchPayload;
  createFitbitAccount: (data: FitbitAccountCreateInput) => FitbitAccount;
  updateFitbitAccount: (
    args: {
      data: FitbitAccountUpdateInput;
      where: FitbitAccountWhereUniqueInput;
    }
  ) => FitbitAccount;
  updateManyFitbitAccounts: (
    args: { data: FitbitAccountUpdateInput; where?: FitbitAccountWhereInput }
  ) => BatchPayload;
  upsertFitbitAccount: (
    args: {
      where: FitbitAccountWhereUniqueInput;
      create: FitbitAccountCreateInput;
      update: FitbitAccountUpdateInput;
    }
  ) => FitbitAccount;
  deleteFitbitAccount: (where: FitbitAccountWhereUniqueInput) => FitbitAccount;
  deleteManyFitbitAccounts: (where?: FitbitAccountWhereInput) => BatchPayload;
  createGoogleFitAccount: (
    data: GoogleFitAccountCreateInput
  ) => GoogleFitAccount;
  updateGoogleFitAccount: (
    args: {
      data: GoogleFitAccountUpdateInput;
      where: GoogleFitAccountWhereUniqueInput;
    }
  ) => GoogleFitAccount;
  updateManyGoogleFitAccounts: (
    args: {
      data: GoogleFitAccountUpdateInput;
      where?: GoogleFitAccountWhereInput;
    }
  ) => BatchPayload;
  upsertGoogleFitAccount: (
    args: {
      where: GoogleFitAccountWhereUniqueInput;
      create: GoogleFitAccountCreateInput;
      update: GoogleFitAccountUpdateInput;
    }
  ) => GoogleFitAccount;
  deleteGoogleFitAccount: (
    where: GoogleFitAccountWhereUniqueInput
  ) => GoogleFitAccount;
  deleteManyGoogleFitAccounts: (
    where?: GoogleFitAccountWhereInput
  ) => BatchPayload;
  createHeartData: (data: HeartDataCreateInput) => HeartData;
  updateHeartData: (
    args: { data: HeartDataUpdateInput; where: HeartDataWhereUniqueInput }
  ) => HeartData;
  updateManyHeartDatas: (
    args: { data: HeartDataUpdateInput; where?: HeartDataWhereInput }
  ) => BatchPayload;
  upsertHeartData: (
    args: {
      where: HeartDataWhereUniqueInput;
      create: HeartDataCreateInput;
      update: HeartDataUpdateInput;
    }
  ) => HeartData;
  deleteHeartData: (where: HeartDataWhereUniqueInput) => HeartData;
  deleteManyHeartDatas: (where?: HeartDataWhereInput) => BatchPayload;
  createHeartLog: (data: HeartLogCreateInput) => HeartLog;
  updateHeartLog: (
    args: { data: HeartLogUpdateInput; where: HeartLogWhereUniqueInput }
  ) => HeartLog;
  updateManyHeartLogs: (
    args: { data: HeartLogUpdateInput; where?: HeartLogWhereInput }
  ) => BatchPayload;
  upsertHeartLog: (
    args: {
      where: HeartLogWhereUniqueInput;
      create: HeartLogCreateInput;
      update: HeartLogUpdateInput;
    }
  ) => HeartLog;
  deleteHeartLog: (where: HeartLogWhereUniqueInput) => HeartLog;
  deleteManyHeartLogs: (where?: HeartLogWhereInput) => BatchPayload;
  createProductivityData: (
    data: ProductivityDataCreateInput
  ) => ProductivityData;
  updateProductivityData: (
    args: {
      data: ProductivityDataUpdateInput;
      where: ProductivityDataWhereUniqueInput;
    }
  ) => ProductivityData;
  updateManyProductivityDatas: (
    args: {
      data: ProductivityDataUpdateInput;
      where?: ProductivityDataWhereInput;
    }
  ) => BatchPayload;
  upsertProductivityData: (
    args: {
      where: ProductivityDataWhereUniqueInput;
      create: ProductivityDataCreateInput;
      update: ProductivityDataUpdateInput;
    }
  ) => ProductivityData;
  deleteProductivityData: (
    where: ProductivityDataWhereUniqueInput
  ) => ProductivityData;
  deleteManyProductivityDatas: (
    where?: ProductivityDataWhereInput
  ) => BatchPayload;
  createRescueTimeAccount: (
    data: RescueTimeAccountCreateInput
  ) => RescueTimeAccount;
  updateRescueTimeAccount: (
    args: {
      data: RescueTimeAccountUpdateInput;
      where: RescueTimeAccountWhereUniqueInput;
    }
  ) => RescueTimeAccount;
  updateManyRescueTimeAccounts: (
    args: {
      data: RescueTimeAccountUpdateInput;
      where?: RescueTimeAccountWhereInput;
    }
  ) => BatchPayload;
  upsertRescueTimeAccount: (
    args: {
      where: RescueTimeAccountWhereUniqueInput;
      create: RescueTimeAccountCreateInput;
      update: RescueTimeAccountUpdateInput;
    }
  ) => RescueTimeAccount;
  deleteRescueTimeAccount: (
    where: RescueTimeAccountWhereUniqueInput
  ) => RescueTimeAccount;
  deleteManyRescueTimeAccounts: (
    where?: RescueTimeAccountWhereInput
  ) => BatchPayload;
  createSleepData: (data: SleepDataCreateInput) => SleepData;
  updateSleepData: (
    args: { data: SleepDataUpdateInput; where: SleepDataWhereUniqueInput }
  ) => SleepData;
  updateManySleepDatas: (
    args: { data: SleepDataUpdateInput; where?: SleepDataWhereInput }
  ) => BatchPayload;
  upsertSleepData: (
    args: {
      where: SleepDataWhereUniqueInput;
      create: SleepDataCreateInput;
      update: SleepDataUpdateInput;
    }
  ) => SleepData;
  deleteSleepData: (where: SleepDataWhereUniqueInput) => SleepData;
  deleteManySleepDatas: (where?: SleepDataWhereInput) => BatchPayload;
  createSleepLog: (data: SleepLogCreateInput) => SleepLog;
  updateSleepLog: (
    args: { data: SleepLogUpdateInput; where: SleepLogWhereUniqueInput }
  ) => SleepLog;
  updateManySleepLogs: (
    args: { data: SleepLogUpdateInput; where?: SleepLogWhereInput }
  ) => BatchPayload;
  upsertSleepLog: (
    args: {
      where: SleepLogWhereUniqueInput;
      create: SleepLogCreateInput;
      update: SleepLogUpdateInput;
    }
  ) => SleepLog;
  deleteSleepLog: (where: SleepLogWhereUniqueInput) => SleepLog;
  deleteManySleepLogs: (where?: SleepLogWhereInput) => BatchPayload;
  createStepData: (data: StepDataCreateInput) => StepData;
  updateStepData: (
    args: { data: StepDataUpdateInput; where: StepDataWhereUniqueInput }
  ) => StepData;
  updateManyStepDatas: (
    args: { data: StepDataUpdateInput; where?: StepDataWhereInput }
  ) => BatchPayload;
  upsertStepData: (
    args: {
      where: StepDataWhereUniqueInput;
      create: StepDataCreateInput;
      update: StepDataUpdateInput;
    }
  ) => StepData;
  deleteStepData: (where: StepDataWhereUniqueInput) => StepData;
  deleteManyStepDatas: (where?: StepDataWhereInput) => BatchPayload;
  createStepLog: (data: StepLogCreateInput) => StepLog;
  updateStepLog: (
    args: { data: StepLogUpdateInput; where: StepLogWhereUniqueInput }
  ) => StepLog;
  updateManyStepLogs: (
    args: { data: StepLogUpdateInput; where?: StepLogWhereInput }
  ) => BatchPayload;
  upsertStepLog: (
    args: {
      where: StepLogWhereUniqueInput;
      create: StepLogCreateInput;
      update: StepLogUpdateInput;
    }
  ) => StepLog;
  deleteStepLog: (where: StepLogWhereUniqueInput) => StepLog;
  deleteManyStepLogs: (where?: StepLogWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  calorieData: (
    where?: CalorieDataSubscriptionWhereInput
  ) => CalorieDataSubscriptionPayloadSubscription;
  calorieLog: (
    where?: CalorieLogSubscriptionWhereInput
  ) => CalorieLogSubscriptionPayloadSubscription;
  distanceData: (
    where?: DistanceDataSubscriptionWhereInput
  ) => DistanceDataSubscriptionPayloadSubscription;
  distanceLog: (
    where?: DistanceLogSubscriptionWhereInput
  ) => DistanceLogSubscriptionPayloadSubscription;
  fitbitAccount: (
    where?: FitbitAccountSubscriptionWhereInput
  ) => FitbitAccountSubscriptionPayloadSubscription;
  googleFitAccount: (
    where?: GoogleFitAccountSubscriptionWhereInput
  ) => GoogleFitAccountSubscriptionPayloadSubscription;
  heartData: (
    where?: HeartDataSubscriptionWhereInput
  ) => HeartDataSubscriptionPayloadSubscription;
  heartLog: (
    where?: HeartLogSubscriptionWhereInput
  ) => HeartLogSubscriptionPayloadSubscription;
  productivityData: (
    where?: ProductivityDataSubscriptionWhereInput
  ) => ProductivityDataSubscriptionPayloadSubscription;
  rescueTimeAccount: (
    where?: RescueTimeAccountSubscriptionWhereInput
  ) => RescueTimeAccountSubscriptionPayloadSubscription;
  sleepData: (
    where?: SleepDataSubscriptionWhereInput
  ) => SleepDataSubscriptionPayloadSubscription;
  sleepLog: (
    where?: SleepLogSubscriptionWhereInput
  ) => SleepLogSubscriptionPayloadSubscription;
  stepData: (
    where?: StepDataSubscriptionWhereInput
  ) => StepDataSubscriptionPayloadSubscription;
  stepLog: (
    where?: StepLogSubscriptionWhereInput
  ) => StepLogSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DistanceDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "distance_ASC"
  | "distance_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SleepLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateOfSleep_ASC"
  | "dateOfSleep_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "efficiency_ASC"
  | "efficiency_DESC"
  | "isMainSleep_ASC"
  | "isMainSleep_DESC"
  | "logId_ASC"
  | "logId_DESC"
  | "minutesAfterWakeup_ASC"
  | "minutesAfterWakeup_DESC"
  | "minutesAsleep_ASC"
  | "minutesAsleep_DESC"
  | "minutesAwake_ASC"
  | "minutesAwake_DESC"
  | "minutesToFallAsleep_ASC"
  | "minutesToFallAsleep_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "timeInBed_ASC"
  | "timeInBed_DESC"
  | "type_ASC"
  | "type_DESC"
  | "summaryDeepCount_ASC"
  | "summaryDeepCount_DESC"
  | "summaryDeepMinutes_ASC"
  | "summaryDeepMinutes_DESC"
  | "summaryDeepThirtyDayAvgMinutes_ASC"
  | "summaryDeepThirtyDayAvgMinutes_DESC"
  | "summaryLightCount_ASC"
  | "summaryLightCount_DESC"
  | "summaryLightMinutes_ASC"
  | "summaryLightMinutes_DESC"
  | "summaryLightThirtyDayAvgMinutes_ASC"
  | "summaryLightThirtyDayAvgMinutes_DESC"
  | "summaryRemCount_ASC"
  | "summaryRemCount_DESC"
  | "summaryRemMinutes_ASC"
  | "summaryRemMinutes_DESC"
  | "summaryRemThirtyDayAvgMinutes_ASC"
  | "summaryRemThirtyDayAvgMinutes_DESC"
  | "summaryWakeCount_ASC"
  | "summaryWakeCount_DESC"
  | "summaryWakeMinutes_ASC"
  | "summaryWakeMinutes_DESC"
  | "summaryWakeThirtyDayAvgMinutes_ASC"
  | "summaryWakeThirtyDayAvgMinutes_DESC"
  | "summaryAsleepCount_ASC"
  | "summaryAsleepCount_DESC"
  | "summaryAsleepMinutes_ASC"
  | "summaryAsleepMinutes_DESC"
  | "summaryAwakeCount_ASC"
  | "summaryAwakeCount_DESC"
  | "summaryAwakeMinutes_ASC"
  | "summaryAwakeMinutes_DESC"
  | "summaryRestlessCount_ASC"
  | "summaryRestlessCount_DESC"
  | "summaryRestlessMinutes_ASC"
  | "summaryRestlessMinutes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DistanceLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "totalDistance_ASC"
  | "totalDistance_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "sleepLogLastUpdatedDate_ASC"
  | "sleepLogLastUpdatedDate_DESC"
  | "productivityDataLastUpdatedDate_ASC"
  | "productivityDataLastUpdatedDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CalorieLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "totalCalories_ASC"
  | "totalCalories_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GoogleFitAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC"
  | "accessToken_ASC"
  | "accessToken_DESC"
  | "expiration_ASC"
  | "expiration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StepDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "steps_ASC"
  | "steps_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CalorieDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "calories_ASC"
  | "calories_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SleepDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "level_ASC"
  | "level_DESC"
  | "second_ASC"
  | "second_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HeartLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "caloriesOutOfRange_ASC"
  | "caloriesOutOfRange_DESC"
  | "minutesOutOfRange_ASC"
  | "minutesOutOfRange_DESC"
  | "maxValueOutOfRange_ASC"
  | "maxValueOutOfRange_DESC"
  | "minValueOutOfRange_ASC"
  | "minValueOutOfRange_DESC"
  | "caloriesFatBurn_ASC"
  | "caloriesFatBurn_DESC"
  | "minutesFatBurn_ASC"
  | "minutesFatBurn_DESC"
  | "maxValueFatBurn_ASC"
  | "maxValueFatBurn_DESC"
  | "minValueFatBurn_ASC"
  | "minValueFatBurn_DESC"
  | "caloriesCardio_ASC"
  | "caloriesCardio_DESC"
  | "minutesCardio_ASC"
  | "minutesCardio_DESC"
  | "maxValueCardio_ASC"
  | "maxValueCardio_DESC"
  | "minValueCardio_ASC"
  | "minValueCardio_DESC"
  | "caloriesPeak_ASC"
  | "caloriesPeak_DESC"
  | "minutesPeak_ASC"
  | "minutesPeak_DESC"
  | "maxValuePeak_ASC"
  | "maxValuePeak_DESC"
  | "minValuePeak_ASC"
  | "minValuePeak_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HeartDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "heartRate_ASC"
  | "heartRate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StepLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "totalSteps_ASC"
  | "totalSteps_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductivityDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "activity_ASC"
  | "activity_DESC"
  | "category_ASC"
  | "category_DESC"
  | "productivity_ASC"
  | "productivity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FitbitAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fitbitUserId_ASC"
  | "fitbitUserId_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC"
  | "accessToken_ASC"
  | "accessToken_DESC"
  | "expiration_ASC"
  | "expiration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RescueTimeAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "accessToken_ASC"
  | "accessToken_DESC"
  | "scope_ASC"
  | "scope_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface HeartLogUpsertWithWhereUniqueWithoutUserInput {
  where: HeartLogWhereUniqueInput;
  update: HeartLogUpdateWithoutUserDataInput;
  create: HeartLogCreateWithoutUserInput;
}

export type CalorieDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HeartDataCreateWithoutHeartLogInput {
  dateTime: DateTimeInput;
  heartRate: Float;
}

export interface HeartDataUpdateInput {
  heartLog?: HeartLogUpdateOneRequiredWithoutHeartDataInput;
  dateTime?: DateTimeInput;
  heartRate?: Float;
}

export interface StepLogCreateManyWithoutUserInput {
  create?: StepLogCreateWithoutUserInput[] | StepLogCreateWithoutUserInput;
  connect?: StepLogWhereUniqueInput[] | StepLogWhereUniqueInput;
}

export interface DistanceLogUpdateManyWithoutUserInput {
  create?:
    | DistanceLogCreateWithoutUserInput[]
    | DistanceLogCreateWithoutUserInput;
  delete?: DistanceLogWhereUniqueInput[] | DistanceLogWhereUniqueInput;
  connect?: DistanceLogWhereUniqueInput[] | DistanceLogWhereUniqueInput;
  disconnect?: DistanceLogWhereUniqueInput[] | DistanceLogWhereUniqueInput;
  update?:
    | DistanceLogUpdateWithWhereUniqueWithoutUserInput[]
    | DistanceLogUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | DistanceLogUpsertWithWhereUniqueWithoutUserInput[]
    | DistanceLogUpsertWithWhereUniqueWithoutUserInput;
}

export interface StepLogCreateWithoutUserInput {
  date: DateTimeInput;
  totalSteps: Int;
  stepData?: StepDataCreateManyWithoutStepLogInput;
}

export interface CalorieLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  totalCalories?: Float;
  totalCalories_not?: Float;
  totalCalories_in?: Float[] | Float;
  totalCalories_not_in?: Float[] | Float;
  totalCalories_lt?: Float;
  totalCalories_lte?: Float;
  totalCalories_gt?: Float;
  totalCalories_gte?: Float;
  calorieData_every?: CalorieDataWhereInput;
  calorieData_some?: CalorieDataWhereInput;
  calorieData_none?: CalorieDataWhereInput;
  AND?: CalorieLogWhereInput[] | CalorieLogWhereInput;
  OR?: CalorieLogWhereInput[] | CalorieLogWhereInput;
  NOT?: CalorieLogWhereInput[] | CalorieLogWhereInput;
}

export interface StepDataCreateManyWithoutStepLogInput {
  create?:
    | StepDataCreateWithoutStepLogInput[]
    | StepDataCreateWithoutStepLogInput;
  connect?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
}

export interface DistanceLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  totalDistance?: Float;
  totalDistance_not?: Float;
  totalDistance_in?: Float[] | Float;
  totalDistance_not_in?: Float[] | Float;
  totalDistance_lt?: Float;
  totalDistance_lte?: Float;
  totalDistance_gt?: Float;
  totalDistance_gte?: Float;
  distanceData_every?: DistanceDataWhereInput;
  distanceData_some?: DistanceDataWhereInput;
  distanceData_none?: DistanceDataWhereInput;
  AND?: DistanceLogWhereInput[] | DistanceLogWhereInput;
  OR?: DistanceLogWhereInput[] | DistanceLogWhereInput;
  NOT?: DistanceLogWhereInput[] | DistanceLogWhereInput;
}

export interface StepDataCreateWithoutStepLogInput {
  dateTime: DateTimeInput;
  steps: Int;
}

export interface ProductivityDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  activity?: String;
  activity_not?: String;
  activity_in?: String[] | String;
  activity_not_in?: String[] | String;
  activity_lt?: String;
  activity_lte?: String;
  activity_gt?: String;
  activity_gte?: String;
  activity_contains?: String;
  activity_not_contains?: String;
  activity_starts_with?: String;
  activity_not_starts_with?: String;
  activity_ends_with?: String;
  activity_not_ends_with?: String;
  category?: String;
  category_not?: String;
  category_in?: String[] | String;
  category_not_in?: String[] | String;
  category_lt?: String;
  category_lte?: String;
  category_gt?: String;
  category_gte?: String;
  category_contains?: String;
  category_not_contains?: String;
  category_starts_with?: String;
  category_not_starts_with?: String;
  category_ends_with?: String;
  category_not_ends_with?: String;
  productivity?: Int;
  productivity_not?: Int;
  productivity_in?: Int[] | Int;
  productivity_not_in?: Int[] | Int;
  productivity_lt?: Int;
  productivity_lte?: Int;
  productivity_gt?: Int;
  productivity_gte?: Int;
  AND?: ProductivityDataWhereInput[] | ProductivityDataWhereInput;
  OR?: ProductivityDataWhereInput[] | ProductivityDataWhereInput;
  NOT?: ProductivityDataWhereInput[] | ProductivityDataWhereInput;
}

export interface DistanceLogCreateManyWithoutUserInput {
  create?:
    | DistanceLogCreateWithoutUserInput[]
    | DistanceLogCreateWithoutUserInput;
  connect?: DistanceLogWhereUniqueInput[] | DistanceLogWhereUniqueInput;
}

export interface SleepDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  sleepLog?: SleepLogWhereInput;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  level?: String;
  level_not?: String;
  level_in?: String[] | String;
  level_not_in?: String[] | String;
  level_lt?: String;
  level_lte?: String;
  level_gt?: String;
  level_gte?: String;
  level_contains?: String;
  level_not_contains?: String;
  level_starts_with?: String;
  level_not_starts_with?: String;
  level_ends_with?: String;
  level_not_ends_with?: String;
  second?: Int;
  second_not?: Int;
  second_in?: Int[] | Int;
  second_not_in?: Int[] | Int;
  second_lt?: Int;
  second_lte?: Int;
  second_gt?: Int;
  second_gte?: Int;
  AND?: SleepDataWhereInput[] | SleepDataWhereInput;
  OR?: SleepDataWhereInput[] | SleepDataWhereInput;
  NOT?: SleepDataWhereInput[] | SleepDataWhereInput;
}

export interface DistanceLogCreateWithoutUserInput {
  date: DateTimeInput;
  totalDistance: Float;
  distanceData?: DistanceDataCreateManyWithoutDistanceLogInput;
}

export interface StepLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StepLogWhereInput;
  AND?: StepLogSubscriptionWhereInput[] | StepLogSubscriptionWhereInput;
  OR?: StepLogSubscriptionWhereInput[] | StepLogSubscriptionWhereInput;
  NOT?: StepLogSubscriptionWhereInput[] | StepLogSubscriptionWhereInput;
}

export interface DistanceDataCreateManyWithoutDistanceLogInput {
  create?:
    | DistanceDataCreateWithoutDistanceLogInput[]
    | DistanceDataCreateWithoutDistanceLogInput;
  connect?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
}

export interface SleepLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SleepLogWhereInput;
  AND?: SleepLogSubscriptionWhereInput[] | SleepLogSubscriptionWhereInput;
  OR?: SleepLogSubscriptionWhereInput[] | SleepLogSubscriptionWhereInput;
  NOT?: SleepLogSubscriptionWhereInput[] | SleepLogSubscriptionWhereInput;
}

export interface DistanceDataCreateWithoutDistanceLogInput {
  dateTime: DateTimeInput;
  distance: Float;
}

export interface SleepDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SleepDataWhereInput;
  AND?: SleepDataSubscriptionWhereInput[] | SleepDataSubscriptionWhereInput;
  OR?: SleepDataSubscriptionWhereInput[] | SleepDataSubscriptionWhereInput;
  NOT?: SleepDataSubscriptionWhereInput[] | SleepDataSubscriptionWhereInput;
}

export interface ProductivityDataCreateManyWithoutUserInput {
  create?:
    | ProductivityDataCreateWithoutUserInput[]
    | ProductivityDataCreateWithoutUserInput;
  connect?:
    | ProductivityDataWhereUniqueInput[]
    | ProductivityDataWhereUniqueInput;
}

export interface RescueTimeAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RescueTimeAccountWhereInput;
  AND?:
    | RescueTimeAccountSubscriptionWhereInput[]
    | RescueTimeAccountSubscriptionWhereInput;
  OR?:
    | RescueTimeAccountSubscriptionWhereInput[]
    | RescueTimeAccountSubscriptionWhereInput;
  NOT?:
    | RescueTimeAccountSubscriptionWhereInput[]
    | RescueTimeAccountSubscriptionWhereInput;
}

export interface ProductivityDataCreateWithoutUserInput {
  startTime: DateTimeInput;
  duration: Int;
  activity: String;
  category: String;
  productivity: Int;
}

export interface ProductivityDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductivityDataWhereInput;
  AND?:
    | ProductivityDataSubscriptionWhereInput[]
    | ProductivityDataSubscriptionWhereInput;
  OR?:
    | ProductivityDataSubscriptionWhereInput[]
    | ProductivityDataSubscriptionWhereInput;
  NOT?:
    | ProductivityDataSubscriptionWhereInput[]
    | ProductivityDataSubscriptionWhereInput;
}

export interface CalorieDataUpdateInput {
  calorieLog?: CalorieLogUpdateOneRequiredWithoutCalorieDataInput;
  dateTime?: DateTimeInput;
  calories?: Float;
}

export interface HeartLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HeartLogWhereInput;
  AND?: HeartLogSubscriptionWhereInput[] | HeartLogSubscriptionWhereInput;
  OR?: HeartLogSubscriptionWhereInput[] | HeartLogSubscriptionWhereInput;
  NOT?: HeartLogSubscriptionWhereInput[] | HeartLogSubscriptionWhereInput;
}

export interface CalorieLogUpdateOneRequiredWithoutCalorieDataInput {
  create?: CalorieLogCreateWithoutCalorieDataInput;
  update?: CalorieLogUpdateWithoutCalorieDataDataInput;
  upsert?: CalorieLogUpsertWithoutCalorieDataInput;
  connect?: CalorieLogWhereUniqueInput;
}

export interface SleepLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  dateOfSleep?: String;
  dateOfSleep_not?: String;
  dateOfSleep_in?: String[] | String;
  dateOfSleep_not_in?: String[] | String;
  dateOfSleep_lt?: String;
  dateOfSleep_lte?: String;
  dateOfSleep_gt?: String;
  dateOfSleep_gte?: String;
  dateOfSleep_contains?: String;
  dateOfSleep_not_contains?: String;
  dateOfSleep_starts_with?: String;
  dateOfSleep_not_starts_with?: String;
  dateOfSleep_ends_with?: String;
  dateOfSleep_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  efficiency?: Int;
  efficiency_not?: Int;
  efficiency_in?: Int[] | Int;
  efficiency_not_in?: Int[] | Int;
  efficiency_lt?: Int;
  efficiency_lte?: Int;
  efficiency_gt?: Int;
  efficiency_gte?: Int;
  isMainSleep?: Boolean;
  isMainSleep_not?: Boolean;
  logId?: Float;
  logId_not?: Float;
  logId_in?: Float[] | Float;
  logId_not_in?: Float[] | Float;
  logId_lt?: Float;
  logId_lte?: Float;
  logId_gt?: Float;
  logId_gte?: Float;
  minutesAfterWakeup?: Int;
  minutesAfterWakeup_not?: Int;
  minutesAfterWakeup_in?: Int[] | Int;
  minutesAfterWakeup_not_in?: Int[] | Int;
  minutesAfterWakeup_lt?: Int;
  minutesAfterWakeup_lte?: Int;
  minutesAfterWakeup_gt?: Int;
  minutesAfterWakeup_gte?: Int;
  minutesAsleep?: Int;
  minutesAsleep_not?: Int;
  minutesAsleep_in?: Int[] | Int;
  minutesAsleep_not_in?: Int[] | Int;
  minutesAsleep_lt?: Int;
  minutesAsleep_lte?: Int;
  minutesAsleep_gt?: Int;
  minutesAsleep_gte?: Int;
  minutesAwake?: Int;
  minutesAwake_not?: Int;
  minutesAwake_in?: Int[] | Int;
  minutesAwake_not_in?: Int[] | Int;
  minutesAwake_lt?: Int;
  minutesAwake_lte?: Int;
  minutesAwake_gt?: Int;
  minutesAwake_gte?: Int;
  minutesToFallAsleep?: Int;
  minutesToFallAsleep_not?: Int;
  minutesToFallAsleep_in?: Int[] | Int;
  minutesToFallAsleep_not_in?: Int[] | Int;
  minutesToFallAsleep_lt?: Int;
  minutesToFallAsleep_lte?: Int;
  minutesToFallAsleep_gt?: Int;
  minutesToFallAsleep_gte?: Int;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  timeInBed?: Int;
  timeInBed_not?: Int;
  timeInBed_in?: Int[] | Int;
  timeInBed_not_in?: Int[] | Int;
  timeInBed_lt?: Int;
  timeInBed_lte?: Int;
  timeInBed_gt?: Int;
  timeInBed_gte?: Int;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  sleepData_every?: SleepDataWhereInput;
  sleepData_some?: SleepDataWhereInput;
  sleepData_none?: SleepDataWhereInput;
  summaryDeepCount?: Int;
  summaryDeepCount_not?: Int;
  summaryDeepCount_in?: Int[] | Int;
  summaryDeepCount_not_in?: Int[] | Int;
  summaryDeepCount_lt?: Int;
  summaryDeepCount_lte?: Int;
  summaryDeepCount_gt?: Int;
  summaryDeepCount_gte?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepMinutes_not?: Int;
  summaryDeepMinutes_in?: Int[] | Int;
  summaryDeepMinutes_not_in?: Int[] | Int;
  summaryDeepMinutes_lt?: Int;
  summaryDeepMinutes_lte?: Int;
  summaryDeepMinutes_gt?: Int;
  summaryDeepMinutes_gte?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes_not?: Int;
  summaryDeepThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryDeepThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryDeepThirtyDayAvgMinutes_lt?: Int;
  summaryDeepThirtyDayAvgMinutes_lte?: Int;
  summaryDeepThirtyDayAvgMinutes_gt?: Int;
  summaryDeepThirtyDayAvgMinutes_gte?: Int;
  summaryLightCount?: Int;
  summaryLightCount_not?: Int;
  summaryLightCount_in?: Int[] | Int;
  summaryLightCount_not_in?: Int[] | Int;
  summaryLightCount_lt?: Int;
  summaryLightCount_lte?: Int;
  summaryLightCount_gt?: Int;
  summaryLightCount_gte?: Int;
  summaryLightMinutes?: Int;
  summaryLightMinutes_not?: Int;
  summaryLightMinutes_in?: Int[] | Int;
  summaryLightMinutes_not_in?: Int[] | Int;
  summaryLightMinutes_lt?: Int;
  summaryLightMinutes_lte?: Int;
  summaryLightMinutes_gt?: Int;
  summaryLightMinutes_gte?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryLightThirtyDayAvgMinutes_not?: Int;
  summaryLightThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryLightThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryLightThirtyDayAvgMinutes_lt?: Int;
  summaryLightThirtyDayAvgMinutes_lte?: Int;
  summaryLightThirtyDayAvgMinutes_gt?: Int;
  summaryLightThirtyDayAvgMinutes_gte?: Int;
  summaryRemCount?: Int;
  summaryRemCount_not?: Int;
  summaryRemCount_in?: Int[] | Int;
  summaryRemCount_not_in?: Int[] | Int;
  summaryRemCount_lt?: Int;
  summaryRemCount_lte?: Int;
  summaryRemCount_gt?: Int;
  summaryRemCount_gte?: Int;
  summaryRemMinutes?: Int;
  summaryRemMinutes_not?: Int;
  summaryRemMinutes_in?: Int[] | Int;
  summaryRemMinutes_not_in?: Int[] | Int;
  summaryRemMinutes_lt?: Int;
  summaryRemMinutes_lte?: Int;
  summaryRemMinutes_gt?: Int;
  summaryRemMinutes_gte?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryRemThirtyDayAvgMinutes_not?: Int;
  summaryRemThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryRemThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryRemThirtyDayAvgMinutes_lt?: Int;
  summaryRemThirtyDayAvgMinutes_lte?: Int;
  summaryRemThirtyDayAvgMinutes_gt?: Int;
  summaryRemThirtyDayAvgMinutes_gte?: Int;
  summaryWakeCount?: Int;
  summaryWakeCount_not?: Int;
  summaryWakeCount_in?: Int[] | Int;
  summaryWakeCount_not_in?: Int[] | Int;
  summaryWakeCount_lt?: Int;
  summaryWakeCount_lte?: Int;
  summaryWakeCount_gt?: Int;
  summaryWakeCount_gte?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeMinutes_not?: Int;
  summaryWakeMinutes_in?: Int[] | Int;
  summaryWakeMinutes_not_in?: Int[] | Int;
  summaryWakeMinutes_lt?: Int;
  summaryWakeMinutes_lte?: Int;
  summaryWakeMinutes_gt?: Int;
  summaryWakeMinutes_gte?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes_not?: Int;
  summaryWakeThirtyDayAvgMinutes_in?: Int[] | Int;
  summaryWakeThirtyDayAvgMinutes_not_in?: Int[] | Int;
  summaryWakeThirtyDayAvgMinutes_lt?: Int;
  summaryWakeThirtyDayAvgMinutes_lte?: Int;
  summaryWakeThirtyDayAvgMinutes_gt?: Int;
  summaryWakeThirtyDayAvgMinutes_gte?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepCount_not?: Int;
  summaryAsleepCount_in?: Int[] | Int;
  summaryAsleepCount_not_in?: Int[] | Int;
  summaryAsleepCount_lt?: Int;
  summaryAsleepCount_lte?: Int;
  summaryAsleepCount_gt?: Int;
  summaryAsleepCount_gte?: Int;
  summaryAsleepMinutes?: Int;
  summaryAsleepMinutes_not?: Int;
  summaryAsleepMinutes_in?: Int[] | Int;
  summaryAsleepMinutes_not_in?: Int[] | Int;
  summaryAsleepMinutes_lt?: Int;
  summaryAsleepMinutes_lte?: Int;
  summaryAsleepMinutes_gt?: Int;
  summaryAsleepMinutes_gte?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeCount_not?: Int;
  summaryAwakeCount_in?: Int[] | Int;
  summaryAwakeCount_not_in?: Int[] | Int;
  summaryAwakeCount_lt?: Int;
  summaryAwakeCount_lte?: Int;
  summaryAwakeCount_gt?: Int;
  summaryAwakeCount_gte?: Int;
  summaryAwakeMinutes?: Int;
  summaryAwakeMinutes_not?: Int;
  summaryAwakeMinutes_in?: Int[] | Int;
  summaryAwakeMinutes_not_in?: Int[] | Int;
  summaryAwakeMinutes_lt?: Int;
  summaryAwakeMinutes_lte?: Int;
  summaryAwakeMinutes_gt?: Int;
  summaryAwakeMinutes_gte?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessCount_not?: Int;
  summaryRestlessCount_in?: Int[] | Int;
  summaryRestlessCount_not_in?: Int[] | Int;
  summaryRestlessCount_lt?: Int;
  summaryRestlessCount_lte?: Int;
  summaryRestlessCount_gt?: Int;
  summaryRestlessCount_gte?: Int;
  summaryRestlessMinutes?: Int;
  summaryRestlessMinutes_not?: Int;
  summaryRestlessMinutes_in?: Int[] | Int;
  summaryRestlessMinutes_not_in?: Int[] | Int;
  summaryRestlessMinutes_lt?: Int;
  summaryRestlessMinutes_lte?: Int;
  summaryRestlessMinutes_gt?: Int;
  summaryRestlessMinutes_gte?: Int;
  AND?: SleepLogWhereInput[] | SleepLogWhereInput;
  OR?: SleepLogWhereInput[] | SleepLogWhereInput;
  NOT?: SleepLogWhereInput[] | SleepLogWhereInput;
}

export interface CalorieLogUpdateWithoutCalorieDataDataInput {
  user?: UserUpdateOneRequiredWithoutCalorieLogsInput;
  date?: DateTimeInput;
  totalCalories?: Float;
}

export interface GoogleFitAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GoogleFitAccountWhereInput;
  AND?:
    | GoogleFitAccountSubscriptionWhereInput[]
    | GoogleFitAccountSubscriptionWhereInput;
  OR?:
    | GoogleFitAccountSubscriptionWhereInput[]
    | GoogleFitAccountSubscriptionWhereInput;
  NOT?:
    | GoogleFitAccountSubscriptionWhereInput[]
    | GoogleFitAccountSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutCalorieLogsInput {
  create?: UserCreateWithoutCalorieLogsInput;
  update?: UserUpdateWithoutCalorieLogsDataInput;
  upsert?: UserUpsertWithoutCalorieLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface DistanceLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DistanceLogWhereInput;
  AND?: DistanceLogSubscriptionWhereInput[] | DistanceLogSubscriptionWhereInput;
  OR?: DistanceLogSubscriptionWhereInput[] | DistanceLogSubscriptionWhereInput;
  NOT?: DistanceLogSubscriptionWhereInput[] | DistanceLogSubscriptionWhereInput;
}

export interface UserUpdateWithoutCalorieLogsDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface CalorieLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CalorieLogWhereInput;
  AND?: CalorieLogSubscriptionWhereInput[] | CalorieLogSubscriptionWhereInput;
  OR?: CalorieLogSubscriptionWhereInput[] | CalorieLogSubscriptionWhereInput;
  NOT?: CalorieLogSubscriptionWhereInput[] | CalorieLogSubscriptionWhereInput;
}

export interface GoogleFitAccountUpdateOneWithoutUserInput {
  create?: GoogleFitAccountCreateWithoutUserInput;
  update?: GoogleFitAccountUpdateWithoutUserDataInput;
  upsert?: GoogleFitAccountUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GoogleFitAccountWhereUniqueInput;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface GoogleFitAccountUpdateWithoutUserDataInput {
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface StepLogUpdateInput {
  user?: UserUpdateOneRequiredWithoutStepLogsInput;
  date?: DateTimeInput;
  totalSteps?: Int;
  stepData?: StepDataUpdateManyWithoutStepLogInput;
}

export interface GoogleFitAccountUpsertWithoutUserInput {
  update: GoogleFitAccountUpdateWithoutUserDataInput;
  create: GoogleFitAccountCreateWithoutUserInput;
}

export interface StepLogCreateInput {
  user: UserCreateOneWithoutStepLogsInput;
  date: DateTimeInput;
  totalSteps: Int;
  stepData?: StepDataCreateManyWithoutStepLogInput;
}

export interface FitbitAccountUpdateOneWithoutUserInput {
  create?: FitbitAccountCreateWithoutUserInput;
  update?: FitbitAccountUpdateWithoutUserDataInput;
  upsert?: FitbitAccountUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FitbitAccountWhereUniqueInput;
}

export interface UserUpsertWithoutStepLogsInput {
  update: UserUpdateWithoutStepLogsDataInput;
  create: UserCreateWithoutStepLogsInput;
}

export interface FitbitAccountUpdateWithoutUserDataInput {
  fitbitUserId?: String;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface UserUpdateWithoutStepLogsDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface FitbitAccountUpsertWithoutUserInput {
  update: FitbitAccountUpdateWithoutUserDataInput;
  create: FitbitAccountCreateWithoutUserInput;
}

export interface StepLogUpdateWithoutStepDataDataInput {
  user?: UserUpdateOneRequiredWithoutStepLogsInput;
  date?: DateTimeInput;
  totalSteps?: Int;
}

export interface RescueTimeAccountUpdateOneWithoutUserInput {
  create?: RescueTimeAccountCreateWithoutUserInput;
  update?: RescueTimeAccountUpdateWithoutUserDataInput;
  upsert?: RescueTimeAccountUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RescueTimeAccountWhereUniqueInput;
}

export interface StepLogUpdateOneRequiredWithoutStepDataInput {
  create?: StepLogCreateWithoutStepDataInput;
  update?: StepLogUpdateWithoutStepDataDataInput;
  upsert?: StepLogUpsertWithoutStepDataInput;
  connect?: StepLogWhereUniqueInput;
}

export interface RescueTimeAccountUpdateWithoutUserDataInput {
  accessToken?: String;
  scope?: String;
}

export interface UserCreateWithoutStepLogsInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface RescueTimeAccountUpsertWithoutUserInput {
  update: RescueTimeAccountUpdateWithoutUserDataInput;
  create: RescueTimeAccountCreateWithoutUserInput;
}

export interface UserCreateOneWithoutStepLogsInput {
  create?: UserCreateWithoutStepLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface SleepLogUpdateManyWithoutUserInput {
  create?: SleepLogCreateWithoutUserInput[] | SleepLogCreateWithoutUserInput;
  delete?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
  connect?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
  disconnect?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
  update?:
    | SleepLogUpdateWithWhereUniqueWithoutUserInput[]
    | SleepLogUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | SleepLogUpsertWithWhereUniqueWithoutUserInput[]
    | SleepLogUpsertWithWhereUniqueWithoutUserInput;
}

export interface StepLogCreateOneWithoutStepDataInput {
  create?: StepLogCreateWithoutStepDataInput;
  connect?: StepLogWhereUniqueInput;
}

export interface SleepLogUpdateWithWhereUniqueWithoutUserInput {
  where: SleepLogWhereUniqueInput;
  data: SleepLogUpdateWithoutUserDataInput;
}

export type GoogleFitAccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SleepLogUpdateWithoutUserDataInput {
  dateOfSleep?: String;
  duration?: Int;
  efficiency?: Int;
  isMainSleep?: Boolean;
  logId?: Float;
  minutesAfterWakeup?: Int;
  minutesAsleep?: Int;
  minutesAwake?: Int;
  minutesToFallAsleep?: Int;
  startTime?: DateTimeInput;
  timeInBed?: Int;
  type?: String;
  sleepData?: SleepDataUpdateManyWithoutSleepLogInput;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepLogCreateInput {
  user: UserCreateOneWithoutSleepLogsInput;
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeInput;
  timeInBed: Int;
  type?: String;
  sleepData?: SleepDataCreateManyWithoutSleepLogInput;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepDataUpdateManyWithoutSleepLogInput {
  create?:
    | SleepDataCreateWithoutSleepLogInput[]
    | SleepDataCreateWithoutSleepLogInput;
  delete?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
  connect?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
  disconnect?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
  update?:
    | SleepDataUpdateWithWhereUniqueWithoutSleepLogInput[]
    | SleepDataUpdateWithWhereUniqueWithoutSleepLogInput;
  upsert?:
    | SleepDataUpsertWithWhereUniqueWithoutSleepLogInput[]
    | SleepDataUpsertWithWhereUniqueWithoutSleepLogInput;
}

export interface UserUpsertWithoutSleepLogsInput {
  update: UserUpdateWithoutSleepLogsDataInput;
  create: UserCreateWithoutSleepLogsInput;
}

export interface SleepDataUpdateWithWhereUniqueWithoutSleepLogInput {
  where: SleepDataWhereUniqueInput;
  data: SleepDataUpdateWithoutSleepLogDataInput;
}

export interface UserUpdateWithoutSleepLogsDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface SleepDataUpdateWithoutSleepLogDataInput {
  dateTime?: DateTimeInput;
  level?: String;
  second?: Int;
}

export interface SleepLogUpdateWithoutSleepDataDataInput {
  user?: UserUpdateOneRequiredWithoutSleepLogsInput;
  dateOfSleep?: String;
  duration?: Int;
  efficiency?: Int;
  isMainSleep?: Boolean;
  logId?: Float;
  minutesAfterWakeup?: Int;
  minutesAsleep?: Int;
  minutesAwake?: Int;
  minutesToFallAsleep?: Int;
  startTime?: DateTimeInput;
  timeInBed?: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepDataUpsertWithWhereUniqueWithoutSleepLogInput {
  where: SleepDataWhereUniqueInput;
  update: SleepDataUpdateWithoutSleepLogDataInput;
  create: SleepDataCreateWithoutSleepLogInput;
}

export interface SleepLogUpdateOneRequiredWithoutSleepDataInput {
  create?: SleepLogCreateWithoutSleepDataInput;
  update?: SleepLogUpdateWithoutSleepDataDataInput;
  upsert?: SleepLogUpsertWithoutSleepDataInput;
  connect?: SleepLogWhereUniqueInput;
}

export interface SleepLogUpsertWithWhereUniqueWithoutUserInput {
  where: SleepLogWhereUniqueInput;
  update: SleepLogUpdateWithoutUserDataInput;
  create: SleepLogCreateWithoutUserInput;
}

export interface UserCreateWithoutSleepLogsInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface HeartLogUpdateManyWithoutUserInput {
  create?: HeartLogCreateWithoutUserInput[] | HeartLogCreateWithoutUserInput;
  delete?: HeartLogWhereUniqueInput[] | HeartLogWhereUniqueInput;
  connect?: HeartLogWhereUniqueInput[] | HeartLogWhereUniqueInput;
  disconnect?: HeartLogWhereUniqueInput[] | HeartLogWhereUniqueInput;
  update?:
    | HeartLogUpdateWithWhereUniqueWithoutUserInput[]
    | HeartLogUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | HeartLogUpsertWithWhereUniqueWithoutUserInput[]
    | HeartLogUpsertWithWhereUniqueWithoutUserInput;
}

export interface UserCreateOneWithoutSleepLogsInput {
  create?: UserCreateWithoutSleepLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface HeartLogUpdateWithWhereUniqueWithoutUserInput {
  where: HeartLogWhereUniqueInput;
  data: HeartLogUpdateWithoutUserDataInput;
}

export interface SleepLogCreateOneWithoutSleepDataInput {
  create?: SleepLogCreateWithoutSleepDataInput;
  connect?: SleepLogWhereUniqueInput;
}

export interface HeartLogUpdateWithoutUserDataInput {
  dateTime?: DateTimeInput;
  caloriesOutOfRange?: Int;
  minutesOutOfRange?: Int;
  maxValueOutOfRange?: Int;
  minValueOutOfRange?: Int;
  caloriesFatBurn?: Int;
  minutesFatBurn?: Int;
  maxValueFatBurn?: Int;
  minValueFatBurn?: Int;
  caloriesCardio?: Int;
  minutesCardio?: Int;
  maxValueCardio?: Int;
  minValueCardio?: Int;
  caloriesPeak?: Int;
  minutesPeak?: Int;
  maxValuePeak?: Int;
  minValuePeak?: Int;
  heartData?: HeartDataUpdateManyWithoutHeartLogInput;
}

export interface SleepDataCreateInput {
  sleepLog: SleepLogCreateOneWithoutSleepDataInput;
  dateTime: DateTimeInput;
  level: String;
  second: Int;
}

export interface HeartDataUpdateManyWithoutHeartLogInput {
  create?:
    | HeartDataCreateWithoutHeartLogInput[]
    | HeartDataCreateWithoutHeartLogInput;
  delete?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
  connect?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
  disconnect?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
  update?:
    | HeartDataUpdateWithWhereUniqueWithoutHeartLogInput[]
    | HeartDataUpdateWithWhereUniqueWithoutHeartLogInput;
  upsert?:
    | HeartDataUpsertWithWhereUniqueWithoutHeartLogInput[]
    | HeartDataUpsertWithWhereUniqueWithoutHeartLogInput;
}

export interface UserUpdateWithoutRescueTimeAccountDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface HeartDataUpdateWithWhereUniqueWithoutHeartLogInput {
  where: HeartDataWhereUniqueInput;
  data: HeartDataUpdateWithoutHeartLogDataInput;
}

export type SleepDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HeartDataUpdateWithoutHeartLogDataInput {
  dateTime?: DateTimeInput;
  heartRate?: Float;
}

export interface UserCreateWithoutRescueTimeAccountInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface HeartDataUpsertWithWhereUniqueWithoutHeartLogInput {
  where: HeartDataWhereUniqueInput;
  update: HeartDataUpdateWithoutHeartLogDataInput;
  create: HeartDataCreateWithoutHeartLogInput;
}

export type SleepLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredWithoutHeartLogsInput {
  create?: UserCreateWithoutHeartLogsInput;
  update?: UserUpdateWithoutHeartLogsDataInput;
  upsert?: UserUpsertWithoutHeartLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithoutProductivityDataInput {
  update: UserUpdateWithoutProductivityDataDataInput;
  create: UserCreateWithoutProductivityDataInput;
}

export interface StepLogUpdateManyWithoutUserInput {
  create?: StepLogCreateWithoutUserInput[] | StepLogCreateWithoutUserInput;
  delete?: StepLogWhereUniqueInput[] | StepLogWhereUniqueInput;
  connect?: StepLogWhereUniqueInput[] | StepLogWhereUniqueInput;
  disconnect?: StepLogWhereUniqueInput[] | StepLogWhereUniqueInput;
  update?:
    | StepLogUpdateWithWhereUniqueWithoutUserInput[]
    | StepLogUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | StepLogUpsertWithWhereUniqueWithoutUserInput[]
    | StepLogUpsertWithWhereUniqueWithoutUserInput;
}

export type StepDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StepLogUpdateWithWhereUniqueWithoutUserInput {
  where: StepLogWhereUniqueInput;
  data: StepLogUpdateWithoutUserDataInput;
}

export interface ProductivityDataUpdateInput {
  user?: UserUpdateOneRequiredWithoutProductivityDataInput;
  startTime?: DateTimeInput;
  duration?: Int;
  activity?: String;
  category?: String;
  productivity?: Int;
}

export interface StepLogUpdateWithoutUserDataInput {
  date?: DateTimeInput;
  totalSteps?: Int;
  stepData?: StepDataUpdateManyWithoutStepLogInput;
}

export type StepLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StepDataUpdateManyWithoutStepLogInput {
  create?:
    | StepDataCreateWithoutStepLogInput[]
    | StepDataCreateWithoutStepLogInput;
  delete?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
  connect?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
  disconnect?: StepDataWhereUniqueInput[] | StepDataWhereUniqueInput;
  update?:
    | StepDataUpdateWithWhereUniqueWithoutStepLogInput[]
    | StepDataUpdateWithWhereUniqueWithoutStepLogInput;
  upsert?:
    | StepDataUpsertWithWhereUniqueWithoutStepLogInput[]
    | StepDataUpsertWithWhereUniqueWithoutStepLogInput;
}

export interface ProductivityDataCreateInput {
  user: UserCreateOneWithoutProductivityDataInput;
  startTime: DateTimeInput;
  duration: Int;
  activity: String;
  category: String;
  productivity: Int;
}

export interface StepDataUpdateWithWhereUniqueWithoutStepLogInput {
  where: StepDataWhereUniqueInput;
  data: StepDataUpdateWithoutStepLogDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface StepDataUpdateWithoutStepLogDataInput {
  dateTime?: DateTimeInput;
  steps?: Int;
}

export interface HeartLogUpsertWithoutHeartDataInput {
  update: HeartLogUpdateWithoutHeartDataDataInput;
  create: HeartLogCreateWithoutHeartDataInput;
}

export interface StepDataUpsertWithWhereUniqueWithoutStepLogInput {
  where: StepDataWhereUniqueInput;
  update: StepDataUpdateWithoutStepLogDataInput;
  create: StepDataCreateWithoutStepLogInput;
}

export interface UserUpdateWithoutHeartLogsDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface StepLogUpsertWithWhereUniqueWithoutUserInput {
  where: StepLogWhereUniqueInput;
  update: StepLogUpdateWithoutUserDataInput;
  create: StepLogCreateWithoutUserInput;
}

export interface CalorieDataCreateInput {
  calorieLog: CalorieLogCreateOneWithoutCalorieDataInput;
  dateTime: DateTimeInput;
  calories: Float;
}

export interface StepLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  totalSteps?: Int;
  totalSteps_not?: Int;
  totalSteps_in?: Int[] | Int;
  totalSteps_not_in?: Int[] | Int;
  totalSteps_lt?: Int;
  totalSteps_lte?: Int;
  totalSteps_gt?: Int;
  totalSteps_gte?: Int;
  stepData_every?: StepDataWhereInput;
  stepData_some?: StepDataWhereInput;
  stepData_none?: StepDataWhereInput;
  AND?: StepLogWhereInput[] | StepLogWhereInput;
  OR?: StepLogWhereInput[] | StepLogWhereInput;
  NOT?: StepLogWhereInput[] | StepLogWhereInput;
}

export interface CalorieLogCreateWithoutCalorieDataInput {
  user: UserCreateOneWithoutCalorieLogsInput;
  date: DateTimeInput;
  totalCalories: Float;
}

export interface DistanceLogUpdateWithWhereUniqueWithoutUserInput {
  where: DistanceLogWhereUniqueInput;
  data: DistanceLogUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutCalorieLogsInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface DistanceLogUpdateWithoutUserDataInput {
  date?: DateTimeInput;
  totalDistance?: Float;
  distanceData?: DistanceDataUpdateManyWithoutDistanceLogInput;
}

export interface GoogleFitAccountCreateWithoutUserInput {
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeInput;
}

export interface DistanceDataUpdateManyWithoutDistanceLogInput {
  create?:
    | DistanceDataCreateWithoutDistanceLogInput[]
    | DistanceDataCreateWithoutDistanceLogInput;
  delete?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
  connect?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
  disconnect?: DistanceDataWhereUniqueInput[] | DistanceDataWhereUniqueInput;
  update?:
    | DistanceDataUpdateWithWhereUniqueWithoutDistanceLogInput[]
    | DistanceDataUpdateWithWhereUniqueWithoutDistanceLogInput;
  upsert?:
    | DistanceDataUpsertWithWhereUniqueWithoutDistanceLogInput[]
    | DistanceDataUpsertWithWhereUniqueWithoutDistanceLogInput;
}

export interface FitbitAccountCreateWithoutUserInput {
  fitbitUserId: String;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeInput;
}

export interface DistanceDataUpdateWithWhereUniqueWithoutDistanceLogInput {
  where: DistanceDataWhereUniqueInput;
  data: DistanceDataUpdateWithoutDistanceLogDataInput;
}

export interface RescueTimeAccountCreateWithoutUserInput {
  accessToken: String;
  scope: String;
}

export interface DistanceDataUpdateWithoutDistanceLogDataInput {
  dateTime?: DateTimeInput;
  distance?: Float;
}

export interface SleepLogCreateWithoutUserInput {
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeInput;
  timeInBed: Int;
  type?: String;
  sleepData?: SleepDataCreateManyWithoutSleepLogInput;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface DistanceDataUpsertWithWhereUniqueWithoutDistanceLogInput {
  where: DistanceDataWhereUniqueInput;
  update: DistanceDataUpdateWithoutDistanceLogDataInput;
  create: DistanceDataCreateWithoutDistanceLogInput;
}

export interface SleepDataCreateWithoutSleepLogInput {
  dateTime: DateTimeInput;
  level: String;
  second: Int;
}

export interface DistanceLogUpsertWithWhereUniqueWithoutUserInput {
  where: DistanceLogWhereUniqueInput;
  update: DistanceLogUpdateWithoutUserDataInput;
  create: DistanceLogCreateWithoutUserInput;
}

export interface HeartLogCreateWithoutUserInput {
  dateTime: DateTimeInput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
  heartData?: HeartDataCreateManyWithoutHeartLogInput;
}

export interface ProductivityDataUpdateManyWithoutUserInput {
  create?:
    | ProductivityDataCreateWithoutUserInput[]
    | ProductivityDataCreateWithoutUserInput;
  delete?:
    | ProductivityDataWhereUniqueInput[]
    | ProductivityDataWhereUniqueInput;
  connect?:
    | ProductivityDataWhereUniqueInput[]
    | ProductivityDataWhereUniqueInput;
  disconnect?:
    | ProductivityDataWhereUniqueInput[]
    | ProductivityDataWhereUniqueInput;
  update?:
    | ProductivityDataUpdateWithWhereUniqueWithoutUserInput[]
    | ProductivityDataUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ProductivityDataUpsertWithWhereUniqueWithoutUserInput[]
    | ProductivityDataUpsertWithWhereUniqueWithoutUserInput;
}

export interface StepDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stepLog?: StepLogWhereInput;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  steps?: Int;
  steps_not?: Int;
  steps_in?: Int[] | Int;
  steps_not_in?: Int[] | Int;
  steps_lt?: Int;
  steps_lte?: Int;
  steps_gt?: Int;
  steps_gte?: Int;
  AND?: StepDataWhereInput[] | StepDataWhereInput;
  OR?: StepDataWhereInput[] | StepDataWhereInput;
  NOT?: StepDataWhereInput[] | StepDataWhereInput;
}

export interface ProductivityDataUpdateWithWhereUniqueWithoutUserInput {
  where: ProductivityDataWhereUniqueInput;
  data: ProductivityDataUpdateWithoutUserDataInput;
}

export interface DistanceDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  distanceLog?: DistanceLogWhereInput;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  distance?: Float;
  distance_not?: Float;
  distance_in?: Float[] | Float;
  distance_not_in?: Float[] | Float;
  distance_lt?: Float;
  distance_lte?: Float;
  distance_gt?: Float;
  distance_gte?: Float;
  AND?: DistanceDataWhereInput[] | DistanceDataWhereInput;
  OR?: DistanceDataWhereInput[] | DistanceDataWhereInput;
  NOT?: DistanceDataWhereInput[] | DistanceDataWhereInput;
}

export interface ProductivityDataUpdateWithoutUserDataInput {
  startTime?: DateTimeInput;
  duration?: Int;
  activity?: String;
  category?: String;
  productivity?: Int;
}

export interface HeartDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  heartLog?: HeartLogWhereInput;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  heartRate?: Float;
  heartRate_not?: Float;
  heartRate_in?: Float[] | Float;
  heartRate_not_in?: Float[] | Float;
  heartRate_lt?: Float;
  heartRate_lte?: Float;
  heartRate_gt?: Float;
  heartRate_gte?: Float;
  AND?: HeartDataWhereInput[] | HeartDataWhereInput;
  OR?: HeartDataWhereInput[] | HeartDataWhereInput;
  NOT?: HeartDataWhereInput[] | HeartDataWhereInput;
}

export interface ProductivityDataUpsertWithWhereUniqueWithoutUserInput {
  where: ProductivityDataWhereUniqueInput;
  update: ProductivityDataUpdateWithoutUserDataInput;
  create: ProductivityDataCreateWithoutUserInput;
}

export interface HeartLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  caloriesOutOfRange?: Int;
  caloriesOutOfRange_not?: Int;
  caloriesOutOfRange_in?: Int[] | Int;
  caloriesOutOfRange_not_in?: Int[] | Int;
  caloriesOutOfRange_lt?: Int;
  caloriesOutOfRange_lte?: Int;
  caloriesOutOfRange_gt?: Int;
  caloriesOutOfRange_gte?: Int;
  minutesOutOfRange?: Int;
  minutesOutOfRange_not?: Int;
  minutesOutOfRange_in?: Int[] | Int;
  minutesOutOfRange_not_in?: Int[] | Int;
  minutesOutOfRange_lt?: Int;
  minutesOutOfRange_lte?: Int;
  minutesOutOfRange_gt?: Int;
  minutesOutOfRange_gte?: Int;
  maxValueOutOfRange?: Int;
  maxValueOutOfRange_not?: Int;
  maxValueOutOfRange_in?: Int[] | Int;
  maxValueOutOfRange_not_in?: Int[] | Int;
  maxValueOutOfRange_lt?: Int;
  maxValueOutOfRange_lte?: Int;
  maxValueOutOfRange_gt?: Int;
  maxValueOutOfRange_gte?: Int;
  minValueOutOfRange?: Int;
  minValueOutOfRange_not?: Int;
  minValueOutOfRange_in?: Int[] | Int;
  minValueOutOfRange_not_in?: Int[] | Int;
  minValueOutOfRange_lt?: Int;
  minValueOutOfRange_lte?: Int;
  minValueOutOfRange_gt?: Int;
  minValueOutOfRange_gte?: Int;
  caloriesFatBurn?: Int;
  caloriesFatBurn_not?: Int;
  caloriesFatBurn_in?: Int[] | Int;
  caloriesFatBurn_not_in?: Int[] | Int;
  caloriesFatBurn_lt?: Int;
  caloriesFatBurn_lte?: Int;
  caloriesFatBurn_gt?: Int;
  caloriesFatBurn_gte?: Int;
  minutesFatBurn?: Int;
  minutesFatBurn_not?: Int;
  minutesFatBurn_in?: Int[] | Int;
  minutesFatBurn_not_in?: Int[] | Int;
  minutesFatBurn_lt?: Int;
  minutesFatBurn_lte?: Int;
  minutesFatBurn_gt?: Int;
  minutesFatBurn_gte?: Int;
  maxValueFatBurn?: Int;
  maxValueFatBurn_not?: Int;
  maxValueFatBurn_in?: Int[] | Int;
  maxValueFatBurn_not_in?: Int[] | Int;
  maxValueFatBurn_lt?: Int;
  maxValueFatBurn_lte?: Int;
  maxValueFatBurn_gt?: Int;
  maxValueFatBurn_gte?: Int;
  minValueFatBurn?: Int;
  minValueFatBurn_not?: Int;
  minValueFatBurn_in?: Int[] | Int;
  minValueFatBurn_not_in?: Int[] | Int;
  minValueFatBurn_lt?: Int;
  minValueFatBurn_lte?: Int;
  minValueFatBurn_gt?: Int;
  minValueFatBurn_gte?: Int;
  caloriesCardio?: Int;
  caloriesCardio_not?: Int;
  caloriesCardio_in?: Int[] | Int;
  caloriesCardio_not_in?: Int[] | Int;
  caloriesCardio_lt?: Int;
  caloriesCardio_lte?: Int;
  caloriesCardio_gt?: Int;
  caloriesCardio_gte?: Int;
  minutesCardio?: Int;
  minutesCardio_not?: Int;
  minutesCardio_in?: Int[] | Int;
  minutesCardio_not_in?: Int[] | Int;
  minutesCardio_lt?: Int;
  minutesCardio_lte?: Int;
  minutesCardio_gt?: Int;
  minutesCardio_gte?: Int;
  maxValueCardio?: Int;
  maxValueCardio_not?: Int;
  maxValueCardio_in?: Int[] | Int;
  maxValueCardio_not_in?: Int[] | Int;
  maxValueCardio_lt?: Int;
  maxValueCardio_lte?: Int;
  maxValueCardio_gt?: Int;
  maxValueCardio_gte?: Int;
  minValueCardio?: Int;
  minValueCardio_not?: Int;
  minValueCardio_in?: Int[] | Int;
  minValueCardio_not_in?: Int[] | Int;
  minValueCardio_lt?: Int;
  minValueCardio_lte?: Int;
  minValueCardio_gt?: Int;
  minValueCardio_gte?: Int;
  caloriesPeak?: Int;
  caloriesPeak_not?: Int;
  caloriesPeak_in?: Int[] | Int;
  caloriesPeak_not_in?: Int[] | Int;
  caloriesPeak_lt?: Int;
  caloriesPeak_lte?: Int;
  caloriesPeak_gt?: Int;
  caloriesPeak_gte?: Int;
  minutesPeak?: Int;
  minutesPeak_not?: Int;
  minutesPeak_in?: Int[] | Int;
  minutesPeak_not_in?: Int[] | Int;
  minutesPeak_lt?: Int;
  minutesPeak_lte?: Int;
  minutesPeak_gt?: Int;
  minutesPeak_gte?: Int;
  maxValuePeak?: Int;
  maxValuePeak_not?: Int;
  maxValuePeak_in?: Int[] | Int;
  maxValuePeak_not_in?: Int[] | Int;
  maxValuePeak_lt?: Int;
  maxValuePeak_lte?: Int;
  maxValuePeak_gt?: Int;
  maxValuePeak_gte?: Int;
  minValuePeak?: Int;
  minValuePeak_not?: Int;
  minValuePeak_in?: Int[] | Int;
  minValuePeak_not_in?: Int[] | Int;
  minValuePeak_lt?: Int;
  minValuePeak_lte?: Int;
  minValuePeak_gt?: Int;
  minValuePeak_gte?: Int;
  heartData_every?: HeartDataWhereInput;
  heartData_some?: HeartDataWhereInput;
  heartData_none?: HeartDataWhereInput;
  AND?: HeartLogWhereInput[] | HeartLogWhereInput;
  OR?: HeartLogWhereInput[] | HeartLogWhereInput;
  NOT?: HeartLogWhereInput[] | HeartLogWhereInput;
}

export interface UserUpsertWithoutCalorieLogsInput {
  update: UserUpdateWithoutCalorieLogsDataInput;
  create: UserCreateWithoutCalorieLogsInput;
}

export interface FitbitAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  fitbitUserId?: String;
  fitbitUserId_not?: String;
  fitbitUserId_in?: String[] | String;
  fitbitUserId_not_in?: String[] | String;
  fitbitUserId_lt?: String;
  fitbitUserId_lte?: String;
  fitbitUserId_gt?: String;
  fitbitUserId_gte?: String;
  fitbitUserId_contains?: String;
  fitbitUserId_not_contains?: String;
  fitbitUserId_starts_with?: String;
  fitbitUserId_not_starts_with?: String;
  fitbitUserId_ends_with?: String;
  fitbitUserId_not_ends_with?: String;
  refreshToken?: String;
  refreshToken_not?: String;
  refreshToken_in?: String[] | String;
  refreshToken_not_in?: String[] | String;
  refreshToken_lt?: String;
  refreshToken_lte?: String;
  refreshToken_gt?: String;
  refreshToken_gte?: String;
  refreshToken_contains?: String;
  refreshToken_not_contains?: String;
  refreshToken_starts_with?: String;
  refreshToken_not_starts_with?: String;
  refreshToken_ends_with?: String;
  refreshToken_not_ends_with?: String;
  accessToken?: String;
  accessToken_not?: String;
  accessToken_in?: String[] | String;
  accessToken_not_in?: String[] | String;
  accessToken_lt?: String;
  accessToken_lte?: String;
  accessToken_gt?: String;
  accessToken_gte?: String;
  accessToken_contains?: String;
  accessToken_not_contains?: String;
  accessToken_starts_with?: String;
  accessToken_not_starts_with?: String;
  accessToken_ends_with?: String;
  accessToken_not_ends_with?: String;
  expiration?: DateTimeInput;
  expiration_not?: DateTimeInput;
  expiration_in?: DateTimeInput[] | DateTimeInput;
  expiration_not_in?: DateTimeInput[] | DateTimeInput;
  expiration_lt?: DateTimeInput;
  expiration_lte?: DateTimeInput;
  expiration_gt?: DateTimeInput;
  expiration_gte?: DateTimeInput;
  AND?: FitbitAccountWhereInput[] | FitbitAccountWhereInput;
  OR?: FitbitAccountWhereInput[] | FitbitAccountWhereInput;
  NOT?: FitbitAccountWhereInput[] | FitbitAccountWhereInput;
}

export interface CalorieLogUpsertWithoutCalorieDataInput {
  update: CalorieLogUpdateWithoutCalorieDataDataInput;
  create: CalorieLogCreateWithoutCalorieDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  googleFitAccount?: GoogleFitAccountWhereInput;
  fitbitAccount?: FitbitAccountWhereInput;
  rescueTimeAccount?: RescueTimeAccountWhereInput;
  sleepLogs_every?: SleepLogWhereInput;
  sleepLogs_some?: SleepLogWhereInput;
  sleepLogs_none?: SleepLogWhereInput;
  heartLogs_every?: HeartLogWhereInput;
  heartLogs_some?: HeartLogWhereInput;
  heartLogs_none?: HeartLogWhereInput;
  stepLogs_every?: StepLogWhereInput;
  stepLogs_some?: StepLogWhereInput;
  stepLogs_none?: StepLogWhereInput;
  calorieLogs_every?: CalorieLogWhereInput;
  calorieLogs_some?: CalorieLogWhereInput;
  calorieLogs_none?: CalorieLogWhereInput;
  distanceLogs_every?: DistanceLogWhereInput;
  distanceLogs_some?: DistanceLogWhereInput;
  distanceLogs_none?: DistanceLogWhereInput;
  productivityData_every?: ProductivityDataWhereInput;
  productivityData_some?: ProductivityDataWhereInput;
  productivityData_none?: ProductivityDataWhereInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  sleepLogLastUpdatedDate_not?: DateTimeInput;
  sleepLogLastUpdatedDate_in?: DateTimeInput[] | DateTimeInput;
  sleepLogLastUpdatedDate_not_in?: DateTimeInput[] | DateTimeInput;
  sleepLogLastUpdatedDate_lt?: DateTimeInput;
  sleepLogLastUpdatedDate_lte?: DateTimeInput;
  sleepLogLastUpdatedDate_gt?: DateTimeInput;
  sleepLogLastUpdatedDate_gte?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate_not?: DateTimeInput;
  productivityDataLastUpdatedDate_in?: DateTimeInput[] | DateTimeInput;
  productivityDataLastUpdatedDate_not_in?: DateTimeInput[] | DateTimeInput;
  productivityDataLastUpdatedDate_lt?: DateTimeInput;
  productivityDataLastUpdatedDate_lte?: DateTimeInput;
  productivityDataLastUpdatedDate_gt?: DateTimeInput;
  productivityDataLastUpdatedDate_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface HeartLogUpdateWithoutHeartDataDataInput {
  user?: UserUpdateOneRequiredWithoutHeartLogsInput;
  dateTime?: DateTimeInput;
  caloriesOutOfRange?: Int;
  minutesOutOfRange?: Int;
  maxValueOutOfRange?: Int;
  minValueOutOfRange?: Int;
  caloriesFatBurn?: Int;
  minutesFatBurn?: Int;
  maxValueFatBurn?: Int;
  minValueFatBurn?: Int;
  caloriesCardio?: Int;
  minutesCardio?: Int;
  maxValueCardio?: Int;
  minValueCardio?: Int;
  caloriesPeak?: Int;
  minutesPeak?: Int;
  maxValuePeak?: Int;
  minValuePeak?: Int;
}

export interface FitbitAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FitbitAccountWhereInput;
  AND?:
    | FitbitAccountSubscriptionWhereInput[]
    | FitbitAccountSubscriptionWhereInput;
  OR?:
    | FitbitAccountSubscriptionWhereInput[]
    | FitbitAccountSubscriptionWhereInput;
  NOT?:
    | FitbitAccountSubscriptionWhereInput[]
    | FitbitAccountSubscriptionWhereInput;
}

export interface HeartLogUpdateOneRequiredWithoutHeartDataInput {
  create?: HeartLogCreateWithoutHeartDataInput;
  update?: HeartLogUpdateWithoutHeartDataDataInput;
  upsert?: HeartLogUpsertWithoutHeartDataInput;
  connect?: HeartLogWhereUniqueInput;
}

export interface CalorieDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CalorieDataWhereInput;
  AND?: CalorieDataSubscriptionWhereInput[] | CalorieDataSubscriptionWhereInput;
  OR?: CalorieDataSubscriptionWhereInput[] | CalorieDataSubscriptionWhereInput;
  NOT?: CalorieDataSubscriptionWhereInput[] | CalorieDataSubscriptionWhereInput;
}

export interface CalorieLogCreateInput {
  user: UserCreateOneWithoutCalorieLogsInput;
  date: DateTimeInput;
  totalCalories: Float;
  calorieData?: CalorieDataCreateManyWithoutCalorieLogInput;
}

export type CalorieLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CalorieDataCreateManyWithoutCalorieLogInput {
  create?:
    | CalorieDataCreateWithoutCalorieLogInput[]
    | CalorieDataCreateWithoutCalorieLogInput;
  connect?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
}

export type DistanceDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CalorieDataCreateWithoutCalorieLogInput {
  dateTime: DateTimeInput;
  calories: Float;
}

export type DistanceLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CalorieLogUpdateInput {
  user?: UserUpdateOneRequiredWithoutCalorieLogsInput;
  date?: DateTimeInput;
  totalCalories?: Float;
  calorieData?: CalorieDataUpdateManyWithoutCalorieLogInput;
}

export type FitbitAccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CalorieDataUpdateManyWithoutCalorieLogInput {
  create?:
    | CalorieDataCreateWithoutCalorieLogInput[]
    | CalorieDataCreateWithoutCalorieLogInput;
  delete?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
  connect?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
  disconnect?: CalorieDataWhereUniqueInput[] | CalorieDataWhereUniqueInput;
  update?:
    | CalorieDataUpdateWithWhereUniqueWithoutCalorieLogInput[]
    | CalorieDataUpdateWithWhereUniqueWithoutCalorieLogInput;
  upsert?:
    | CalorieDataUpsertWithWhereUniqueWithoutCalorieLogInput[]
    | CalorieDataUpsertWithWhereUniqueWithoutCalorieLogInput;
}

export interface StepDataCreateInput {
  stepLog: StepLogCreateOneWithoutStepDataInput;
  dateTime: DateTimeInput;
  steps: Int;
}

export interface CalorieDataUpdateWithWhereUniqueWithoutCalorieLogInput {
  where: CalorieDataWhereUniqueInput;
  data: CalorieDataUpdateWithoutCalorieLogDataInput;
}

export interface SleepLogUpsertWithoutSleepDataInput {
  update: SleepLogUpdateWithoutSleepDataDataInput;
  create: SleepLogCreateWithoutSleepDataInput;
}

export interface CalorieDataUpdateWithoutCalorieLogDataInput {
  dateTime?: DateTimeInput;
  calories?: Float;
}

export interface UserUpdateOneRequiredWithoutSleepLogsInput {
  create?: UserCreateWithoutSleepLogsInput;
  update?: UserUpdateWithoutSleepLogsDataInput;
  upsert?: UserUpsertWithoutSleepLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface CalorieDataUpsertWithWhereUniqueWithoutCalorieLogInput {
  where: CalorieDataWhereUniqueInput;
  update: CalorieDataUpdateWithoutCalorieLogDataInput;
  create: CalorieDataCreateWithoutCalorieLogInput;
}

export interface SleepDataUpdateInput {
  sleepLog?: SleepLogUpdateOneRequiredWithoutSleepDataInput;
  dateTime?: DateTimeInput;
  level?: String;
  second?: Int;
}

export interface DistanceDataCreateInput {
  distanceLog: DistanceLogCreateOneWithoutDistanceDataInput;
  dateTime: DateTimeInput;
  distance: Float;
}

export interface SleepLogCreateWithoutSleepDataInput {
  user: UserCreateOneWithoutSleepLogsInput;
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeInput;
  timeInBed: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface DistanceLogCreateOneWithoutDistanceDataInput {
  create?: DistanceLogCreateWithoutDistanceDataInput;
  connect?: DistanceLogWhereUniqueInput;
}

export interface UserUpsertWithoutRescueTimeAccountInput {
  update: UserUpdateWithoutRescueTimeAccountDataInput;
  create: UserCreateWithoutRescueTimeAccountInput;
}

export interface DistanceLogCreateWithoutDistanceDataInput {
  user: UserCreateOneWithoutDistanceLogsInput;
  date: DateTimeInput;
  totalDistance: Float;
}

export interface RescueTimeAccountUpdateInput {
  user?: UserUpdateOneRequiredWithoutRescueTimeAccountInput;
  accessToken?: String;
  scope?: String;
}

export interface UserCreateOneWithoutDistanceLogsInput {
  create?: UserCreateWithoutDistanceLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface RescueTimeAccountCreateInput {
  user: UserCreateOneWithoutRescueTimeAccountInput;
  accessToken: String;
  scope: String;
}

export interface UserCreateWithoutDistanceLogsInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface UserUpdateOneRequiredWithoutProductivityDataInput {
  create?: UserCreateWithoutProductivityDataInput;
  update?: UserUpdateWithoutProductivityDataDataInput;
  upsert?: UserUpsertWithoutProductivityDataInput;
  connect?: UserWhereUniqueInput;
}

export interface CalorieLogCreateManyWithoutUserInput {
  create?:
    | CalorieLogCreateWithoutUserInput[]
    | CalorieLogCreateWithoutUserInput;
  connect?: CalorieLogWhereUniqueInput[] | CalorieLogWhereUniqueInput;
}

export interface UserCreateOneWithoutProductivityDataInput {
  create?: UserCreateWithoutProductivityDataInput;
  connect?: UserWhereUniqueInput;
}

export interface CalorieLogCreateWithoutUserInput {
  date: DateTimeInput;
  totalCalories: Float;
  calorieData?: CalorieDataCreateManyWithoutCalorieLogInput;
}

export interface HeartLogCreateInput {
  user: UserCreateOneWithoutHeartLogsInput;
  dateTime: DateTimeInput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
  heartData?: HeartDataCreateManyWithoutHeartLogInput;
}

export interface DistanceDataUpdateInput {
  distanceLog?: DistanceLogUpdateOneRequiredWithoutDistanceDataInput;
  dateTime?: DateTimeInput;
  distance?: Float;
}

export interface UserCreateOneWithoutCalorieLogsInput {
  create?: UserCreateWithoutCalorieLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface DistanceLogUpdateOneRequiredWithoutDistanceDataInput {
  create?: DistanceLogCreateWithoutDistanceDataInput;
  update?: DistanceLogUpdateWithoutDistanceDataDataInput;
  upsert?: DistanceLogUpsertWithoutDistanceDataInput;
  connect?: DistanceLogWhereUniqueInput;
}

export interface FitbitAccountCreateOneWithoutUserInput {
  create?: FitbitAccountCreateWithoutUserInput;
  connect?: FitbitAccountWhereUniqueInput;
}

export interface DistanceLogUpdateWithoutDistanceDataDataInput {
  user?: UserUpdateOneRequiredWithoutDistanceLogsInput;
  date?: DateTimeInput;
  totalDistance?: Float;
}

export interface SleepLogCreateManyWithoutUserInput {
  create?: SleepLogCreateWithoutUserInput[] | SleepLogCreateWithoutUserInput;
  connect?: SleepLogWhereUniqueInput[] | SleepLogWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutDistanceLogsInput {
  create?: UserCreateWithoutDistanceLogsInput;
  update?: UserUpdateWithoutDistanceLogsDataInput;
  upsert?: UserUpsertWithoutDistanceLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface HeartLogCreateManyWithoutUserInput {
  create?: HeartLogCreateWithoutUserInput[] | HeartLogCreateWithoutUserInput;
  connect?: HeartLogWhereUniqueInput[] | HeartLogWhereUniqueInput;
}

export interface UserUpdateWithoutDistanceLogsDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface CalorieDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  calorieLog?: CalorieLogWhereInput;
  dateTime?: DateTimeInput;
  dateTime_not?: DateTimeInput;
  dateTime_in?: DateTimeInput[] | DateTimeInput;
  dateTime_not_in?: DateTimeInput[] | DateTimeInput;
  dateTime_lt?: DateTimeInput;
  dateTime_lte?: DateTimeInput;
  dateTime_gt?: DateTimeInput;
  dateTime_gte?: DateTimeInput;
  calories?: Float;
  calories_not?: Float;
  calories_in?: Float[] | Float;
  calories_not_in?: Float[] | Float;
  calories_lt?: Float;
  calories_lte?: Float;
  calories_gt?: Float;
  calories_gte?: Float;
  AND?: CalorieDataWhereInput[] | CalorieDataWhereInput;
  OR?: CalorieDataWhereInput[] | CalorieDataWhereInput;
  NOT?: CalorieDataWhereInput[] | CalorieDataWhereInput;
}

export interface CalorieLogUpdateManyWithoutUserInput {
  create?:
    | CalorieLogCreateWithoutUserInput[]
    | CalorieLogCreateWithoutUserInput;
  delete?: CalorieLogWhereUniqueInput[] | CalorieLogWhereUniqueInput;
  connect?: CalorieLogWhereUniqueInput[] | CalorieLogWhereUniqueInput;
  disconnect?: CalorieLogWhereUniqueInput[] | CalorieLogWhereUniqueInput;
  update?:
    | CalorieLogUpdateWithWhereUniqueWithoutUserInput[]
    | CalorieLogUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CalorieLogUpsertWithWhereUniqueWithoutUserInput[]
    | CalorieLogUpsertWithWhereUniqueWithoutUserInput;
}

export interface StepDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StepDataWhereInput;
  AND?: StepDataSubscriptionWhereInput[] | StepDataSubscriptionWhereInput;
  OR?: StepDataSubscriptionWhereInput[] | StepDataSubscriptionWhereInput;
  NOT?: StepDataSubscriptionWhereInput[] | StepDataSubscriptionWhereInput;
}

export interface CalorieLogUpdateWithWhereUniqueWithoutUserInput {
  where: CalorieLogWhereUniqueInput;
  data: CalorieLogUpdateWithoutUserDataInput;
}

export interface GoogleFitAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  refreshToken?: String;
  refreshToken_not?: String;
  refreshToken_in?: String[] | String;
  refreshToken_not_in?: String[] | String;
  refreshToken_lt?: String;
  refreshToken_lte?: String;
  refreshToken_gt?: String;
  refreshToken_gte?: String;
  refreshToken_contains?: String;
  refreshToken_not_contains?: String;
  refreshToken_starts_with?: String;
  refreshToken_not_starts_with?: String;
  refreshToken_ends_with?: String;
  refreshToken_not_ends_with?: String;
  accessToken?: String;
  accessToken_not?: String;
  accessToken_in?: String[] | String;
  accessToken_not_in?: String[] | String;
  accessToken_lt?: String;
  accessToken_lte?: String;
  accessToken_gt?: String;
  accessToken_gte?: String;
  accessToken_contains?: String;
  accessToken_not_contains?: String;
  accessToken_starts_with?: String;
  accessToken_not_starts_with?: String;
  accessToken_ends_with?: String;
  accessToken_not_ends_with?: String;
  expiration?: DateTimeInput;
  expiration_not?: DateTimeInput;
  expiration_in?: DateTimeInput[] | DateTimeInput;
  expiration_not_in?: DateTimeInput[] | DateTimeInput;
  expiration_lt?: DateTimeInput;
  expiration_lte?: DateTimeInput;
  expiration_gt?: DateTimeInput;
  expiration_gte?: DateTimeInput;
  AND?: GoogleFitAccountWhereInput[] | GoogleFitAccountWhereInput;
  OR?: GoogleFitAccountWhereInput[] | GoogleFitAccountWhereInput;
  NOT?: GoogleFitAccountWhereInput[] | GoogleFitAccountWhereInput;
}

export interface CalorieLogUpdateWithoutUserDataInput {
  date?: DateTimeInput;
  totalCalories?: Float;
  calorieData?: CalorieDataUpdateManyWithoutCalorieLogInput;
}

export interface DistanceDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DistanceDataWhereInput;
  AND?:
    | DistanceDataSubscriptionWhereInput[]
    | DistanceDataSubscriptionWhereInput;
  OR?:
    | DistanceDataSubscriptionWhereInput[]
    | DistanceDataSubscriptionWhereInput;
  NOT?:
    | DistanceDataSubscriptionWhereInput[]
    | DistanceDataSubscriptionWhereInput;
}

export interface CalorieLogUpsertWithWhereUniqueWithoutUserInput {
  where: CalorieLogWhereUniqueInput;
  update: CalorieLogUpdateWithoutUserDataInput;
  create: CalorieLogCreateWithoutUserInput;
}

export interface StepLogUpsertWithoutStepDataInput {
  update: StepLogUpdateWithoutStepDataDataInput;
  create: StepLogCreateWithoutStepDataInput;
}

export interface UserUpsertWithoutDistanceLogsInput {
  update: UserUpdateWithoutDistanceLogsDataInput;
  create: UserCreateWithoutDistanceLogsInput;
}

export interface StepDataUpdateInput {
  stepLog?: StepLogUpdateOneRequiredWithoutStepDataInput;
  dateTime?: DateTimeInput;
  steps?: Int;
}

export interface DistanceLogUpsertWithoutDistanceDataInput {
  update: DistanceLogUpdateWithoutDistanceDataDataInput;
  create: DistanceLogCreateWithoutDistanceDataInput;
}

export interface SleepLogUpdateInput {
  user?: UserUpdateOneRequiredWithoutSleepLogsInput;
  dateOfSleep?: String;
  duration?: Int;
  efficiency?: Int;
  isMainSleep?: Boolean;
  logId?: Float;
  minutesAfterWakeup?: Int;
  minutesAsleep?: Int;
  minutesAwake?: Int;
  minutesToFallAsleep?: Int;
  startTime?: DateTimeInput;
  timeInBed?: Int;
  type?: String;
  sleepData?: SleepDataUpdateManyWithoutSleepLogInput;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface DistanceLogCreateInput {
  user: UserCreateOneWithoutDistanceLogsInput;
  date: DateTimeInput;
  totalDistance: Float;
  distanceData?: DistanceDataCreateManyWithoutDistanceLogInput;
}

export type HeartLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DistanceLogUpdateInput {
  user?: UserUpdateOneRequiredWithoutDistanceLogsInput;
  date?: DateTimeInput;
  totalDistance?: Float;
  distanceData?: DistanceDataUpdateManyWithoutDistanceLogInput;
}

export type RescueTimeAccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FitbitAccountCreateInput {
  user: UserCreateOneWithoutFitbitAccountInput;
  fitbitUserId: String;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeInput;
}

export interface UserCreateOneWithoutRescueTimeAccountInput {
  create?: UserCreateWithoutRescueTimeAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutFitbitAccountInput {
  create?: UserCreateWithoutFitbitAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutProductivityDataInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface UserCreateWithoutFitbitAccountInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface UserUpsertWithoutHeartLogsInput {
  update: UserUpdateWithoutHeartLogsDataInput;
  create: UserCreateWithoutHeartLogsInput;
}

export interface FitbitAccountUpdateInput {
  user?: UserUpdateOneRequiredWithoutFitbitAccountInput;
  fitbitUserId?: String;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface GoogleFitAccountCreateOneWithoutUserInput {
  create?: GoogleFitAccountCreateWithoutUserInput;
  connect?: GoogleFitAccountWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutFitbitAccountInput {
  create?: UserCreateWithoutFitbitAccountInput;
  update?: UserUpdateWithoutFitbitAccountDataInput;
  upsert?: UserUpsertWithoutFitbitAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface SleepDataCreateManyWithoutSleepLogInput {
  create?:
    | SleepDataCreateWithoutSleepLogInput[]
    | SleepDataCreateWithoutSleepLogInput;
  connect?: SleepDataWhereUniqueInput[] | SleepDataWhereUniqueInput;
}

export interface UserUpdateWithoutFitbitAccountDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserUpsertWithoutFitbitAccountInput {
  update: UserUpdateWithoutFitbitAccountDataInput;
  create: UserCreateWithoutFitbitAccountInput;
}

export interface HeartDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HeartDataWhereInput;
  AND?: HeartDataSubscriptionWhereInput[] | HeartDataSubscriptionWhereInput;
  OR?: HeartDataSubscriptionWhereInput[] | HeartDataSubscriptionWhereInput;
  NOT?: HeartDataSubscriptionWhereInput[] | HeartDataSubscriptionWhereInput;
}

export interface GoogleFitAccountCreateInput {
  user: UserCreateOneWithoutGoogleFitAccountInput;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeInput;
}

export interface UserUpdateOneRequiredWithoutStepLogsInput {
  create?: UserCreateWithoutStepLogsInput;
  update?: UserUpdateWithoutStepLogsDataInput;
  upsert?: UserUpsertWithoutStepLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutGoogleFitAccountInput {
  create?: UserCreateWithoutGoogleFitAccountInput;
  connect?: UserWhereUniqueInput;
}

export type HeartDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateWithoutGoogleFitAccountInput {
  email: String;
  password: String;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface UserUpdateOneRequiredWithoutRescueTimeAccountInput {
  create?: UserCreateWithoutRescueTimeAccountInput;
  update?: UserUpdateWithoutRescueTimeAccountDataInput;
  upsert?: UserUpsertWithoutRescueTimeAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface GoogleFitAccountUpdateInput {
  user?: UserUpdateOneRequiredWithoutGoogleFitAccountInput;
  refreshToken?: String;
  accessToken?: String;
  expiration?: DateTimeInput;
}

export interface HeartLogUpdateInput {
  user?: UserUpdateOneRequiredWithoutHeartLogsInput;
  dateTime?: DateTimeInput;
  caloriesOutOfRange?: Int;
  minutesOutOfRange?: Int;
  maxValueOutOfRange?: Int;
  minValueOutOfRange?: Int;
  caloriesFatBurn?: Int;
  minutesFatBurn?: Int;
  maxValueFatBurn?: Int;
  minValueFatBurn?: Int;
  caloriesCardio?: Int;
  minutesCardio?: Int;
  maxValueCardio?: Int;
  minValueCardio?: Int;
  caloriesPeak?: Int;
  minutesPeak?: Int;
  maxValuePeak?: Int;
  minValuePeak?: Int;
  heartData?: HeartDataUpdateManyWithoutHeartLogInput;
}

export interface UserUpdateOneRequiredWithoutGoogleFitAccountInput {
  create?: UserCreateWithoutGoogleFitAccountInput;
  update?: UserUpdateWithoutGoogleFitAccountDataInput;
  upsert?: UserUpsertWithoutGoogleFitAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface RescueTimeAccountCreateOneWithoutUserInput {
  create?: RescueTimeAccountCreateWithoutUserInput;
  connect?: RescueTimeAccountWhereUniqueInput;
}

export interface UserUpdateWithoutGoogleFitAccountDataInput {
  email?: String;
  password?: String;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  productivityData?: ProductivityDataUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface RescueTimeAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  accessToken?: String;
  accessToken_not?: String;
  accessToken_in?: String[] | String;
  accessToken_not_in?: String[] | String;
  accessToken_lt?: String;
  accessToken_lte?: String;
  accessToken_gt?: String;
  accessToken_gte?: String;
  accessToken_contains?: String;
  accessToken_not_contains?: String;
  accessToken_starts_with?: String;
  accessToken_not_starts_with?: String;
  accessToken_ends_with?: String;
  accessToken_not_ends_with?: String;
  scope?: String;
  scope_not?: String;
  scope_in?: String[] | String;
  scope_not_in?: String[] | String;
  scope_lt?: String;
  scope_lte?: String;
  scope_gt?: String;
  scope_gte?: String;
  scope_contains?: String;
  scope_not_contains?: String;
  scope_starts_with?: String;
  scope_not_starts_with?: String;
  scope_ends_with?: String;
  scope_not_ends_with?: String;
  AND?: RescueTimeAccountWhereInput[] | RescueTimeAccountWhereInput;
  OR?: RescueTimeAccountWhereInput[] | RescueTimeAccountWhereInput;
  NOT?: RescueTimeAccountWhereInput[] | RescueTimeAccountWhereInput;
}

export interface UserUpsertWithoutGoogleFitAccountInput {
  update: UserUpdateWithoutGoogleFitAccountDataInput;
  create: UserCreateWithoutGoogleFitAccountInput;
}

export interface StepLogCreateWithoutStepDataInput {
  user: UserCreateOneWithoutStepLogsInput;
  date: DateTimeInput;
  totalSteps: Int;
}

export interface HeartDataCreateInput {
  heartLog: HeartLogCreateOneWithoutHeartDataInput;
  dateTime: DateTimeInput;
  heartRate: Float;
}

export interface UserUpdateWithoutProductivityDataDataInput {
  email?: String;
  password?: String;
  googleFitAccount?: GoogleFitAccountUpdateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountUpdateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountUpdateOneWithoutUserInput;
  sleepLogs?: SleepLogUpdateManyWithoutUserInput;
  heartLogs?: HeartLogUpdateManyWithoutUserInput;
  stepLogs?: StepLogUpdateManyWithoutUserInput;
  calorieLogs?: CalorieLogUpdateManyWithoutUserInput;
  distanceLogs?: DistanceLogUpdateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface UserCreateWithoutHeartLogsInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface UserCreateOneWithoutHeartLogsInput {
  create?: UserCreateWithoutHeartLogsInput;
  connect?: UserWhereUniqueInput;
}

export interface HeartLogCreateWithoutHeartDataInput {
  user: UserCreateOneWithoutHeartLogsInput;
  dateTime: DateTimeInput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
}

export interface HeartLogCreateOneWithoutHeartDataInput {
  create?: HeartLogCreateWithoutHeartDataInput;
  connect?: HeartLogWhereUniqueInput;
}

export interface CalorieLogCreateOneWithoutCalorieDataInput {
  create?: CalorieLogCreateWithoutCalorieDataInput;
  connect?: CalorieLogWhereUniqueInput;
}

export type ProductivityDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateInput {
  email: String;
  password: String;
  googleFitAccount?: GoogleFitAccountCreateOneWithoutUserInput;
  fitbitAccount?: FitbitAccountCreateOneWithoutUserInput;
  rescueTimeAccount?: RescueTimeAccountCreateOneWithoutUserInput;
  sleepLogs?: SleepLogCreateManyWithoutUserInput;
  heartLogs?: HeartLogCreateManyWithoutUserInput;
  stepLogs?: StepLogCreateManyWithoutUserInput;
  calorieLogs?: CalorieLogCreateManyWithoutUserInput;
  distanceLogs?: DistanceLogCreateManyWithoutUserInput;
  productivityData?: ProductivityDataCreateManyWithoutUserInput;
  sleepLogLastUpdatedDate?: DateTimeInput;
  productivityDataLastUpdatedDate?: DateTimeInput;
}

export interface HeartDataCreateManyWithoutHeartLogInput {
  create?:
    | HeartDataCreateWithoutHeartLogInput[]
    | HeartDataCreateWithoutHeartLogInput;
  connect?: HeartDataWhereUniqueInput[] | HeartDataWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  email: String;
  password: String;
  sleepLogLastUpdatedDate?: DateTimeOutput;
  productivityDataLastUpdatedDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  sleepLogLastUpdatedDate: () => Promise<DateTimeOutput>;
  productivityDataLastUpdatedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  sleepLogLastUpdatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  productivityDataLastUpdatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCalorieLogNode {
  count: Int;
}

export interface AggregateCalorieLog
  extends Promise<AggregateCalorieLogNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCalorieLogSubscription
  extends Promise<AsyncIterator<AggregateCalorieLogNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StepDataPreviousValuesNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  steps: Int;
}

export interface StepDataPreviousValues
  extends Promise<StepDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  steps: () => Promise<Int>;
}

export interface StepDataPreviousValuesSubscription
  extends Promise<AsyncIterator<StepDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  steps: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieLogEdgeNode {
  cursor: String;
}

export interface CalorieLogEdge
  extends Promise<CalorieLogEdgeNode>,
    Fragmentable {
  node: <T = CalorieLog>() => T;
  cursor: () => Promise<String>;
}

export interface CalorieLogEdgeSubscription
  extends Promise<AsyncIterator<CalorieLogEdgeNode>>,
    Fragmentable {
  node: <T = CalorieLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCalorieDataNode {
  count: Int;
}

export interface AggregateCalorieData
  extends Promise<AggregateCalorieDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCalorieDataSubscription
  extends Promise<AsyncIterator<AggregateCalorieDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieLogConnectionNode {}

export interface CalorieLogConnection
  extends Promise<CalorieLogConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CalorieLogEdgeNode>>() => T;
  aggregate: <T = AggregateCalorieLog>() => T;
}

export interface CalorieLogConnectionSubscription
  extends Promise<AsyncIterator<CalorieLogConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CalorieLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCalorieLogSubscription>() => T;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdgeNode>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CalorieDataEdgeNode {
  cursor: String;
}

export interface CalorieDataEdge
  extends Promise<CalorieDataEdgeNode>,
    Fragmentable {
  node: <T = CalorieData>() => T;
  cursor: () => Promise<String>;
}

export interface CalorieDataEdgeSubscription
  extends Promise<AsyncIterator<CalorieDataEdgeNode>>,
    Fragmentable {
  node: <T = CalorieDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStepLogNode {
  count: Int;
}

export interface AggregateStepLog
  extends Promise<AggregateStepLogNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepLogSubscription
  extends Promise<AsyncIterator<AggregateStepLogNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface StepLogConnectionNode {}

export interface StepLogConnection
  extends Promise<StepLogConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<StepLogEdgeNode>>() => T;
  aggregate: <T = AggregateStepLog>() => T;
}

export interface StepLogConnectionSubscription
  extends Promise<AsyncIterator<StepLogConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepLogSubscription>() => T;
}

export interface CalorieDataConnectionNode {}

export interface CalorieDataConnection
  extends Promise<CalorieDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CalorieDataEdgeNode>>() => T;
  aggregate: <T = AggregateCalorieData>() => T;
}

export interface CalorieDataConnectionSubscription
  extends Promise<AsyncIterator<CalorieDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CalorieDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCalorieDataSubscription>() => T;
}

export interface StepDataEdgeNode {
  cursor: String;
}

export interface StepDataEdge extends Promise<StepDataEdgeNode>, Fragmentable {
  node: <T = StepData>() => T;
  cursor: () => Promise<String>;
}

export interface StepDataEdgeSubscription
  extends Promise<AsyncIterator<StepDataEdgeNode>>,
    Fragmentable {
  node: <T = StepDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CalorieDataNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  calories: Float;
}

export interface CalorieData extends Promise<CalorieDataNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  calorieLog: <T = CalorieLog>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  calories: () => Promise<Float>;
}

export interface CalorieDataSubscription
  extends Promise<AsyncIterator<CalorieDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  calorieLog: <T = CalorieLogSubscription>() => T;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  calories: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateSleepLogNode {
  count: Int;
}

export interface AggregateSleepLog
  extends Promise<AggregateSleepLogNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSleepLogSubscription
  extends Promise<AsyncIterator<AggregateSleepLogNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CalorieDataSubscriptionPayload
  extends Promise<CalorieDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CalorieData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CalorieDataPreviousValues>() => T;
}

export interface CalorieDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CalorieDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CalorieDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CalorieDataPreviousValuesSubscription>() => T;
}

export interface SleepLogConnectionNode {}

export interface SleepLogConnection
  extends Promise<SleepLogConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<SleepLogEdgeNode>>() => T;
  aggregate: <T = AggregateSleepLog>() => T;
}

export interface SleepLogConnectionSubscription
  extends Promise<AsyncIterator<SleepLogConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SleepLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSleepLogSubscription>() => T;
}

export interface CalorieDataPreviousValuesNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  calories: Float;
}

export interface CalorieDataPreviousValues
  extends Promise<CalorieDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  calories: () => Promise<Float>;
}

export interface CalorieDataPreviousValuesSubscription
  extends Promise<AsyncIterator<CalorieDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  calories: () => Promise<AsyncIterator<Float>>;
}

export interface SleepDataEdgeNode {
  cursor: String;
}

export interface SleepDataEdge
  extends Promise<SleepDataEdgeNode>,
    Fragmentable {
  node: <T = SleepData>() => T;
  cursor: () => Promise<String>;
}

export interface SleepDataEdgeSubscription
  extends Promise<AsyncIterator<SleepDataEdgeNode>>,
    Fragmentable {
  node: <T = SleepDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StepLogSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StepLogSubscriptionPayload
  extends Promise<StepLogSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepLog>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepLogPreviousValues>() => T;
}

export interface StepLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepLogSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepLogPreviousValuesSubscription>() => T;
}

export interface AggregateRescueTimeAccountNode {
  count: Int;
}

export interface AggregateRescueTimeAccount
  extends Promise<AggregateRescueTimeAccountNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRescueTimeAccountSubscription
  extends Promise<AsyncIterator<AggregateRescueTimeAccountNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalorieLogSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CalorieLogSubscriptionPayload
  extends Promise<CalorieLogSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CalorieLog>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CalorieLogPreviousValues>() => T;
}

export interface CalorieLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CalorieLogSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CalorieLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CalorieLogPreviousValuesSubscription>() => T;
}

export interface RescueTimeAccountConnectionNode {}

export interface RescueTimeAccountConnection
  extends Promise<RescueTimeAccountConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<RescueTimeAccountEdgeNode>>() => T;
  aggregate: <T = AggregateRescueTimeAccount>() => T;
}

export interface RescueTimeAccountConnectionSubscription
  extends Promise<AsyncIterator<RescueTimeAccountConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RescueTimeAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRescueTimeAccountSubscription>() => T;
}

export interface CalorieLogPreviousValuesNode {
  id: ID_Output;
  date: DateTimeOutput;
  totalCalories: Float;
}

export interface CalorieLogPreviousValues
  extends Promise<CalorieLogPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalCalories: () => Promise<Float>;
}

export interface CalorieLogPreviousValuesSubscription
  extends Promise<AsyncIterator<CalorieLogPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalCalories: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateProductivityDataNode {
  count: Int;
}

export interface AggregateProductivityData
  extends Promise<AggregateProductivityDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductivityDataSubscription
  extends Promise<AsyncIterator<AggregateProductivityDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductivityDataNode {
  id: ID_Output;
  startTime: DateTimeOutput;
  duration: Int;
  activity: String;
  category: String;
  productivity: Int;
}

export interface ProductivityData
  extends Promise<ProductivityDataNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  startTime: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  activity: () => Promise<String>;
  category: () => Promise<String>;
  productivity: () => Promise<Int>;
}

export interface ProductivityDataSubscription
  extends Promise<AsyncIterator<ProductivityDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Int>>;
  activity: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  productivity: () => Promise<AsyncIterator<Int>>;
}

export interface ProductivityDataConnectionNode {}

export interface ProductivityDataConnection
  extends Promise<ProductivityDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ProductivityDataEdgeNode>>() => T;
  aggregate: <T = AggregateProductivityData>() => T;
}

export interface ProductivityDataConnectionSubscription
  extends Promise<AsyncIterator<ProductivityDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductivityDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductivityDataSubscription>() => T;
}

export interface DistanceDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DistanceDataSubscriptionPayload
  extends Promise<DistanceDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DistanceData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DistanceDataPreviousValues>() => T;
}

export interface DistanceDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DistanceDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DistanceDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DistanceDataPreviousValuesSubscription>() => T;
}

export interface HeartLogEdgeNode {
  cursor: String;
}

export interface HeartLogEdge extends Promise<HeartLogEdgeNode>, Fragmentable {
  node: <T = HeartLog>() => T;
  cursor: () => Promise<String>;
}

export interface HeartLogEdgeSubscription
  extends Promise<AsyncIterator<HeartLogEdgeNode>>,
    Fragmentable {
  node: <T = HeartLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DistanceDataPreviousValuesNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  distance: Float;
}

export interface DistanceDataPreviousValues
  extends Promise<DistanceDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  distance: () => Promise<Float>;
}

export interface DistanceDataPreviousValuesSubscription
  extends Promise<AsyncIterator<DistanceDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  distance: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateHeartDataNode {
  count: Int;
}

export interface AggregateHeartData
  extends Promise<AggregateHeartDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeartDataSubscription
  extends Promise<AsyncIterator<AggregateHeartDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FitbitAccountNode {
  id: ID_Output;
  fitbitUserId: String;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface FitbitAccount
  extends Promise<FitbitAccountNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  fitbitUserId: () => Promise<String>;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface FitbitAccountSubscription
  extends Promise<AsyncIterator<FitbitAccountNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  fitbitUserId: () => Promise<AsyncIterator<String>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HeartDataConnectionNode {}

export interface HeartDataConnection
  extends Promise<HeartDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<HeartDataEdgeNode>>() => T;
  aggregate: <T = AggregateHeartData>() => T;
}

export interface HeartDataConnectionSubscription
  extends Promise<AsyncIterator<HeartDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeartDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeartDataSubscription>() => T;
}

export interface DistanceLogSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DistanceLogSubscriptionPayload
  extends Promise<DistanceLogSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DistanceLog>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DistanceLogPreviousValues>() => T;
}

export interface DistanceLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DistanceLogSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DistanceLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DistanceLogPreviousValuesSubscription>() => T;
}

export interface GoogleFitAccountEdgeNode {
  cursor: String;
}

export interface GoogleFitAccountEdge
  extends Promise<GoogleFitAccountEdgeNode>,
    Fragmentable {
  node: <T = GoogleFitAccount>() => T;
  cursor: () => Promise<String>;
}

export interface GoogleFitAccountEdgeSubscription
  extends Promise<AsyncIterator<GoogleFitAccountEdgeNode>>,
    Fragmentable {
  node: <T = GoogleFitAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DistanceLogPreviousValuesNode {
  id: ID_Output;
  date: DateTimeOutput;
  totalDistance: Float;
}

export interface DistanceLogPreviousValues
  extends Promise<DistanceLogPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalDistance: () => Promise<Float>;
}

export interface DistanceLogPreviousValuesSubscription
  extends Promise<AsyncIterator<DistanceLogPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalDistance: () => Promise<AsyncIterator<Float>>;
}

export interface StepLogPreviousValuesNode {
  id: ID_Output;
  date: DateTimeOutput;
  totalSteps: Int;
}

export interface StepLogPreviousValues
  extends Promise<StepLogPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  totalSteps: () => Promise<Int>;
}

export interface StepLogPreviousValuesSubscription
  extends Promise<AsyncIterator<StepLogPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalSteps: () => Promise<AsyncIterator<Int>>;
}

export interface DistanceDataNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  distance: Float;
}

export interface DistanceData extends Promise<DistanceDataNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  distanceLog: <T = DistanceLog>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  distance: () => Promise<Float>;
}

export interface DistanceDataSubscription
  extends Promise<AsyncIterator<DistanceDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  distanceLog: <T = DistanceLogSubscription>() => T;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  distance: () => Promise<AsyncIterator<Float>>;
}

export interface FitbitAccountEdgeNode {
  cursor: String;
}

export interface FitbitAccountEdge
  extends Promise<FitbitAccountEdgeNode>,
    Fragmentable {
  node: <T = FitbitAccount>() => T;
  cursor: () => Promise<String>;
}

export interface FitbitAccountEdgeSubscription
  extends Promise<AsyncIterator<FitbitAccountEdgeNode>>,
    Fragmentable {
  node: <T = FitbitAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FitbitAccountSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FitbitAccountSubscriptionPayload
  extends Promise<FitbitAccountSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FitbitAccount>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FitbitAccountPreviousValues>() => T;
}

export interface FitbitAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FitbitAccountSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FitbitAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FitbitAccountPreviousValuesSubscription>() => T;
}

export interface GoogleFitAccountNode {
  id: ID_Output;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface GoogleFitAccount
  extends Promise<GoogleFitAccountNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface GoogleFitAccountSubscription
  extends Promise<AsyncIterator<GoogleFitAccountNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FitbitAccountPreviousValuesNode {
  id: ID_Output;
  fitbitUserId: String;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface FitbitAccountPreviousValues
  extends Promise<FitbitAccountPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fitbitUserId: () => Promise<String>;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface FitbitAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<FitbitAccountPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fitbitUserId: () => Promise<AsyncIterator<String>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DistanceLogEdgeNode {
  cursor: String;
}

export interface DistanceLogEdge
  extends Promise<DistanceLogEdgeNode>,
    Fragmentable {
  node: <T = DistanceLog>() => T;
  cursor: () => Promise<String>;
}

export interface DistanceLogEdgeSubscription
  extends Promise<AsyncIterator<DistanceLogEdgeNode>>,
    Fragmentable {
  node: <T = DistanceLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RescueTimeAccountNode {
  id: ID_Output;
  accessToken: String;
  scope: String;
}

export interface RescueTimeAccount
  extends Promise<RescueTimeAccountNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  accessToken: () => Promise<String>;
  scope: () => Promise<String>;
}

export interface RescueTimeAccountSubscription
  extends Promise<AsyncIterator<RescueTimeAccountNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  accessToken: () => Promise<AsyncIterator<String>>;
  scope: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDistanceDataNode {
  count: Int;
}

export interface AggregateDistanceData
  extends Promise<AggregateDistanceDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDistanceDataSubscription
  extends Promise<AsyncIterator<AggregateDistanceDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GoogleFitAccountSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GoogleFitAccountSubscriptionPayload
  extends Promise<GoogleFitAccountSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GoogleFitAccount>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GoogleFitAccountPreviousValues>() => T;
}

export interface GoogleFitAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GoogleFitAccountSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GoogleFitAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GoogleFitAccountPreviousValuesSubscription>() => T;
}

export interface DistanceDataConnectionNode {}

export interface DistanceDataConnection
  extends Promise<DistanceDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DistanceDataEdgeNode>>() => T;
  aggregate: <T = AggregateDistanceData>() => T;
}

export interface DistanceDataConnectionSubscription
  extends Promise<AsyncIterator<DistanceDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DistanceDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDistanceDataSubscription>() => T;
}

export interface GoogleFitAccountPreviousValuesNode {
  id: ID_Output;
  refreshToken: String;
  accessToken: String;
  expiration: DateTimeOutput;
}

export interface GoogleFitAccountPreviousValues
  extends Promise<GoogleFitAccountPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  refreshToken: () => Promise<String>;
  accessToken: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface GoogleFitAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<GoogleFitAccountPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DistanceLogNode {
  id: ID_Output;
  date: DateTimeOutput;
  totalDistance: Float;
}

export interface DistanceLog extends Promise<DistanceLogNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  date: () => Promise<DateTimeOutput>;
  totalDistance: () => Promise<Float>;
  distanceData: <T = FragmentableArray<DistanceDataNode>>(
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DistanceLogSubscription
  extends Promise<AsyncIterator<DistanceLogNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalDistance: () => Promise<AsyncIterator<Float>>;
  distanceData: <T = Promise<AsyncIterator<DistanceDataSubscription>>>(
    args?: {
      where?: DistanceDataWhereInput;
      orderBy?: DistanceDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StepLogEdgeNode {
  cursor: String;
}

export interface StepLogEdge extends Promise<StepLogEdgeNode>, Fragmentable {
  node: <T = StepLog>() => T;
  cursor: () => Promise<String>;
}

export interface StepLogEdgeSubscription
  extends Promise<AsyncIterator<StepLogEdgeNode>>,
    Fragmentable {
  node: <T = StepLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HeartDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HeartDataSubscriptionPayload
  extends Promise<HeartDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeartData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HeartDataPreviousValues>() => T;
}

export interface HeartDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeartDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeartDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HeartDataPreviousValuesSubscription>() => T;
}

export interface StepDataConnectionNode {}

export interface StepDataConnection
  extends Promise<StepDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<StepDataEdgeNode>>() => T;
  aggregate: <T = AggregateStepData>() => T;
}

export interface StepDataConnectionSubscription
  extends Promise<AsyncIterator<StepDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepDataSubscription>() => T;
}

export interface HeartDataPreviousValuesNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  heartRate: Float;
}

export interface HeartDataPreviousValues
  extends Promise<HeartDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  heartRate: () => Promise<Float>;
}

export interface HeartDataPreviousValuesSubscription
  extends Promise<AsyncIterator<HeartDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  heartRate: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateSleepDataNode {
  count: Int;
}

export interface AggregateSleepData
  extends Promise<AggregateSleepDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSleepDataSubscription
  extends Promise<AsyncIterator<AggregateSleepDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StepDataNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  steps: Int;
}

export interface StepData extends Promise<StepDataNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  stepLog: <T = StepLog>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  steps: () => Promise<Int>;
}

export interface StepDataSubscription
  extends Promise<AsyncIterator<StepDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stepLog: <T = StepLogSubscription>() => T;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  steps: () => Promise<AsyncIterator<Int>>;
}

export interface RescueTimeAccountEdgeNode {
  cursor: String;
}

export interface RescueTimeAccountEdge
  extends Promise<RescueTimeAccountEdgeNode>,
    Fragmentable {
  node: <T = RescueTimeAccount>() => T;
  cursor: () => Promise<String>;
}

export interface RescueTimeAccountEdgeSubscription
  extends Promise<AsyncIterator<RescueTimeAccountEdgeNode>>,
    Fragmentable {
  node: <T = RescueTimeAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HeartLogSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HeartLogSubscriptionPayload
  extends Promise<HeartLogSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeartLog>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HeartLogPreviousValues>() => T;
}

export interface HeartLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeartLogSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeartLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HeartLogPreviousValuesSubscription>() => T;
}

export interface ProductivityDataEdgeNode {
  cursor: String;
}

export interface ProductivityDataEdge
  extends Promise<ProductivityDataEdgeNode>,
    Fragmentable {
  node: <T = ProductivityData>() => T;
  cursor: () => Promise<String>;
}

export interface ProductivityDataEdgeSubscription
  extends Promise<AsyncIterator<ProductivityDataEdgeNode>>,
    Fragmentable {
  node: <T = ProductivityDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HeartLogPreviousValuesNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
}

export interface HeartLogPreviousValues
  extends Promise<HeartLogPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  caloriesOutOfRange: () => Promise<Int>;
  minutesOutOfRange: () => Promise<Int>;
  maxValueOutOfRange: () => Promise<Int>;
  minValueOutOfRange: () => Promise<Int>;
  caloriesFatBurn: () => Promise<Int>;
  minutesFatBurn: () => Promise<Int>;
  maxValueFatBurn: () => Promise<Int>;
  minValueFatBurn: () => Promise<Int>;
  caloriesCardio: () => Promise<Int>;
  minutesCardio: () => Promise<Int>;
  maxValueCardio: () => Promise<Int>;
  minValueCardio: () => Promise<Int>;
  caloriesPeak: () => Promise<Int>;
  minutesPeak: () => Promise<Int>;
  maxValuePeak: () => Promise<Int>;
  minValuePeak: () => Promise<Int>;
}

export interface HeartLogPreviousValuesSubscription
  extends Promise<AsyncIterator<HeartLogPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  caloriesOutOfRange: () => Promise<AsyncIterator<Int>>;
  minutesOutOfRange: () => Promise<AsyncIterator<Int>>;
  maxValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  minValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  caloriesFatBurn: () => Promise<AsyncIterator<Int>>;
  minutesFatBurn: () => Promise<AsyncIterator<Int>>;
  maxValueFatBurn: () => Promise<AsyncIterator<Int>>;
  minValueFatBurn: () => Promise<AsyncIterator<Int>>;
  caloriesCardio: () => Promise<AsyncIterator<Int>>;
  minutesCardio: () => Promise<AsyncIterator<Int>>;
  maxValueCardio: () => Promise<AsyncIterator<Int>>;
  minValueCardio: () => Promise<AsyncIterator<Int>>;
  caloriesPeak: () => Promise<AsyncIterator<Int>>;
  minutesPeak: () => Promise<AsyncIterator<Int>>;
  maxValuePeak: () => Promise<AsyncIterator<Int>>;
  minValuePeak: () => Promise<AsyncIterator<Int>>;
}

export interface HeartLogConnectionNode {}

export interface HeartLogConnection
  extends Promise<HeartLogConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<HeartLogEdgeNode>>() => T;
  aggregate: <T = AggregateHeartLog>() => T;
}

export interface HeartLogConnectionSubscription
  extends Promise<AsyncIterator<HeartLogConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeartLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeartLogSubscription>() => T;
}

export interface StepLogNode {
  id: ID_Output;
  date: DateTimeOutput;
  totalSteps: Int;
}

export interface StepLog extends Promise<StepLogNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  date: () => Promise<DateTimeOutput>;
  totalSteps: () => Promise<Int>;
  stepData: <T = FragmentableArray<StepDataNode>>(
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StepLogSubscription
  extends Promise<AsyncIterator<StepLogNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalSteps: () => Promise<AsyncIterator<Int>>;
  stepData: <T = Promise<AsyncIterator<StepDataSubscription>>>(
    args?: {
      where?: StepDataWhereInput;
      orderBy?: StepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateGoogleFitAccountNode {
  count: Int;
}

export interface AggregateGoogleFitAccount
  extends Promise<AggregateGoogleFitAccountNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGoogleFitAccountSubscription
  extends Promise<AsyncIterator<AggregateGoogleFitAccountNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductivityDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProductivityDataSubscriptionPayload
  extends Promise<ProductivityDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductivityData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductivityDataPreviousValues>() => T;
}

export interface ProductivityDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductivityDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductivityDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductivityDataPreviousValuesSubscription>() => T;
}

export interface AggregateFitbitAccountNode {
  count: Int;
}

export interface AggregateFitbitAccount
  extends Promise<AggregateFitbitAccountNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFitbitAccountSubscription
  extends Promise<AsyncIterator<AggregateFitbitAccountNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductivityDataPreviousValuesNode {
  id: ID_Output;
  startTime: DateTimeOutput;
  duration: Int;
  activity: String;
  category: String;
  productivity: Int;
}

export interface ProductivityDataPreviousValues
  extends Promise<ProductivityDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  duration: () => Promise<Int>;
  activity: () => Promise<String>;
  category: () => Promise<String>;
  productivity: () => Promise<Int>;
}

export interface ProductivityDataPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductivityDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Int>>;
  activity: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  productivity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateDistanceLogNode {
  count: Int;
}

export interface AggregateDistanceLog
  extends Promise<AggregateDistanceLogNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDistanceLogSubscription
  extends Promise<AsyncIterator<AggregateDistanceLogNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HeartDataNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  heartRate: Float;
}

export interface HeartData extends Promise<HeartDataNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  heartLog: <T = HeartLog>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  heartRate: () => Promise<Float>;
}

export interface HeartDataSubscription
  extends Promise<AsyncIterator<HeartDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  heartLog: <T = HeartLogSubscription>() => T;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  heartRate: () => Promise<AsyncIterator<Float>>;
}

export interface DistanceDataEdgeNode {
  cursor: String;
}

export interface DistanceDataEdge
  extends Promise<DistanceDataEdgeNode>,
    Fragmentable {
  node: <T = DistanceData>() => T;
  cursor: () => Promise<String>;
}

export interface DistanceDataEdgeSubscription
  extends Promise<AsyncIterator<DistanceDataEdgeNode>>,
    Fragmentable {
  node: <T = DistanceDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RescueTimeAccountSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RescueTimeAccountSubscriptionPayload
  extends Promise<RescueTimeAccountSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RescueTimeAccount>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RescueTimeAccountPreviousValues>() => T;
}

export interface RescueTimeAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RescueTimeAccountSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RescueTimeAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RescueTimeAccountPreviousValuesSubscription>() => T;
}

export interface CalorieLogNode {
  id: ID_Output;
  date: DateTimeOutput;
  totalCalories: Float;
}

export interface CalorieLog extends Promise<CalorieLogNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  date: () => Promise<DateTimeOutput>;
  totalCalories: () => Promise<Float>;
  calorieData: <T = FragmentableArray<CalorieDataNode>>(
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CalorieLogSubscription
  extends Promise<AsyncIterator<CalorieLogNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  totalCalories: () => Promise<AsyncIterator<Float>>;
  calorieData: <T = Promise<AsyncIterator<CalorieDataSubscription>>>(
    args?: {
      where?: CalorieDataWhereInput;
      orderBy?: CalorieDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RescueTimeAccountPreviousValuesNode {
  id: ID_Output;
  accessToken: String;
  scope: String;
}

export interface RescueTimeAccountPreviousValues
  extends Promise<RescueTimeAccountPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  accessToken: () => Promise<String>;
  scope: () => Promise<String>;
}

export interface RescueTimeAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<RescueTimeAccountPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  accessToken: () => Promise<AsyncIterator<String>>;
  scope: () => Promise<AsyncIterator<String>>;
}

export interface SleepLogEdgeNode {
  cursor: String;
}

export interface SleepLogEdge extends Promise<SleepLogEdgeNode>, Fragmentable {
  node: <T = SleepLog>() => T;
  cursor: () => Promise<String>;
}

export interface SleepLogEdgeSubscription
  extends Promise<AsyncIterator<SleepLogEdgeNode>>,
    Fragmentable {
  node: <T = SleepLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HeartLogNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  caloriesOutOfRange: Int;
  minutesOutOfRange: Int;
  maxValueOutOfRange: Int;
  minValueOutOfRange: Int;
  caloriesFatBurn: Int;
  minutesFatBurn: Int;
  maxValueFatBurn: Int;
  minValueFatBurn: Int;
  caloriesCardio: Int;
  minutesCardio: Int;
  maxValueCardio: Int;
  minValueCardio: Int;
  caloriesPeak: Int;
  minutesPeak: Int;
  maxValuePeak: Int;
  minValuePeak: Int;
}

export interface HeartLog extends Promise<HeartLogNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  caloriesOutOfRange: () => Promise<Int>;
  minutesOutOfRange: () => Promise<Int>;
  maxValueOutOfRange: () => Promise<Int>;
  minValueOutOfRange: () => Promise<Int>;
  caloriesFatBurn: () => Promise<Int>;
  minutesFatBurn: () => Promise<Int>;
  maxValueFatBurn: () => Promise<Int>;
  minValueFatBurn: () => Promise<Int>;
  caloriesCardio: () => Promise<Int>;
  minutesCardio: () => Promise<Int>;
  maxValueCardio: () => Promise<Int>;
  minValueCardio: () => Promise<Int>;
  caloriesPeak: () => Promise<Int>;
  minutesPeak: () => Promise<Int>;
  maxValuePeak: () => Promise<Int>;
  minValuePeak: () => Promise<Int>;
  heartData: <T = FragmentableArray<HeartDataNode>>(
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HeartLogSubscription
  extends Promise<AsyncIterator<HeartLogNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  caloriesOutOfRange: () => Promise<AsyncIterator<Int>>;
  minutesOutOfRange: () => Promise<AsyncIterator<Int>>;
  maxValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  minValueOutOfRange: () => Promise<AsyncIterator<Int>>;
  caloriesFatBurn: () => Promise<AsyncIterator<Int>>;
  minutesFatBurn: () => Promise<AsyncIterator<Int>>;
  maxValueFatBurn: () => Promise<AsyncIterator<Int>>;
  minValueFatBurn: () => Promise<AsyncIterator<Int>>;
  caloriesCardio: () => Promise<AsyncIterator<Int>>;
  minutesCardio: () => Promise<AsyncIterator<Int>>;
  maxValueCardio: () => Promise<AsyncIterator<Int>>;
  minValueCardio: () => Promise<AsyncIterator<Int>>;
  caloriesPeak: () => Promise<AsyncIterator<Int>>;
  minutesPeak: () => Promise<AsyncIterator<Int>>;
  maxValuePeak: () => Promise<AsyncIterator<Int>>;
  minValuePeak: () => Promise<AsyncIterator<Int>>;
  heartData: <T = Promise<AsyncIterator<HeartDataSubscription>>>(
    args?: {
      where?: HeartDataWhereInput;
      orderBy?: HeartDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserNode {
  id: ID_Output;
  email: String;
  password: String;
  sleepLogLastUpdatedDate?: DateTimeOutput;
  productivityDataLastUpdatedDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  googleFitAccount: <T = GoogleFitAccount>() => T;
  fitbitAccount: <T = FitbitAccount>() => T;
  rescueTimeAccount: <T = RescueTimeAccount>() => T;
  sleepLogs: <T = FragmentableArray<SleepLogNode>>(
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  heartLogs: <T = FragmentableArray<HeartLogNode>>(
    args?: {
      where?: HeartLogWhereInput;
      orderBy?: HeartLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  stepLogs: <T = FragmentableArray<StepLogNode>>(
    args?: {
      where?: StepLogWhereInput;
      orderBy?: StepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  calorieLogs: <T = FragmentableArray<CalorieLogNode>>(
    args?: {
      where?: CalorieLogWhereInput;
      orderBy?: CalorieLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  distanceLogs: <T = FragmentableArray<DistanceLogNode>>(
    args?: {
      where?: DistanceLogWhereInput;
      orderBy?: DistanceLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  productivityData: <T = FragmentableArray<ProductivityDataNode>>(
    args?: {
      where?: ProductivityDataWhereInput;
      orderBy?: ProductivityDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sleepLogLastUpdatedDate: () => Promise<DateTimeOutput>;
  productivityDataLastUpdatedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  googleFitAccount: <T = GoogleFitAccountSubscription>() => T;
  fitbitAccount: <T = FitbitAccountSubscription>() => T;
  rescueTimeAccount: <T = RescueTimeAccountSubscription>() => T;
  sleepLogs: <T = Promise<AsyncIterator<SleepLogSubscription>>>(
    args?: {
      where?: SleepLogWhereInput;
      orderBy?: SleepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  heartLogs: <T = Promise<AsyncIterator<HeartLogSubscription>>>(
    args?: {
      where?: HeartLogWhereInput;
      orderBy?: HeartLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  stepLogs: <T = Promise<AsyncIterator<StepLogSubscription>>>(
    args?: {
      where?: StepLogWhereInput;
      orderBy?: StepLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  calorieLogs: <T = Promise<AsyncIterator<CalorieLogSubscription>>>(
    args?: {
      where?: CalorieLogWhereInput;
      orderBy?: CalorieLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  distanceLogs: <T = Promise<AsyncIterator<DistanceLogSubscription>>>(
    args?: {
      where?: DistanceLogWhereInput;
      orderBy?: DistanceLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  productivityData: <T = Promise<AsyncIterator<ProductivityDataSubscription>>>(
    args?: {
      where?: ProductivityDataWhereInput;
      orderBy?: ProductivityDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sleepLogLastUpdatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  productivityDataLastUpdatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SleepDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SleepDataSubscriptionPayload
  extends Promise<SleepDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SleepData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SleepDataPreviousValues>() => T;
}

export interface SleepDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SleepDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SleepDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SleepDataPreviousValuesSubscription>() => T;
}

export interface HeartDataEdgeNode {
  cursor: String;
}

export interface HeartDataEdge
  extends Promise<HeartDataEdgeNode>,
    Fragmentable {
  node: <T = HeartData>() => T;
  cursor: () => Promise<String>;
}

export interface HeartDataEdgeSubscription
  extends Promise<AsyncIterator<HeartDataEdgeNode>>,
    Fragmentable {
  node: <T = HeartDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SleepDataPreviousValuesNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  level: String;
  second: Int;
}

export interface SleepDataPreviousValues
  extends Promise<SleepDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  level: () => Promise<String>;
  second: () => Promise<Int>;
}

export interface SleepDataPreviousValuesSubscription
  extends Promise<AsyncIterator<SleepDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  level: () => Promise<AsyncIterator<String>>;
  second: () => Promise<AsyncIterator<Int>>;
}

export interface FitbitAccountConnectionNode {}

export interface FitbitAccountConnection
  extends Promise<FitbitAccountConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<FitbitAccountEdgeNode>>() => T;
  aggregate: <T = AggregateFitbitAccount>() => T;
}

export interface FitbitAccountConnectionSubscription
  extends Promise<AsyncIterator<FitbitAccountConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FitbitAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFitbitAccountSubscription>() => T;
}

export interface SleepDataNode {
  id: ID_Output;
  dateTime: DateTimeOutput;
  level: String;
  second: Int;
}

export interface SleepData extends Promise<SleepDataNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  sleepLog: <T = SleepLog>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  level: () => Promise<String>;
  second: () => Promise<Int>;
}

export interface SleepDataSubscription
  extends Promise<AsyncIterator<SleepDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sleepLog: <T = SleepLogSubscription>() => T;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  level: () => Promise<AsyncIterator<String>>;
  second: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface SleepDataConnectionNode {}

export interface SleepDataConnection
  extends Promise<SleepDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<SleepDataEdgeNode>>() => T;
  aggregate: <T = AggregateSleepData>() => T;
}

export interface SleepDataConnectionSubscription
  extends Promise<AsyncIterator<SleepDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SleepDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSleepDataSubscription>() => T;
}

export interface StepDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StepDataSubscriptionPayload
  extends Promise<StepDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepDataPreviousValues>() => T;
}

export interface StepDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepDataPreviousValuesSubscription>() => T;
}

export interface SleepLogNode {
  id: ID_Output;
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeOutput;
  timeInBed: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepLog extends Promise<SleepLogNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
  dateOfSleep: () => Promise<String>;
  duration: () => Promise<Int>;
  efficiency: () => Promise<Int>;
  isMainSleep: () => Promise<Boolean>;
  logId: () => Promise<Float>;
  minutesAfterWakeup: () => Promise<Int>;
  minutesAsleep: () => Promise<Int>;
  minutesAwake: () => Promise<Int>;
  minutesToFallAsleep: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  timeInBed: () => Promise<Int>;
  type: () => Promise<String>;
  sleepData: <T = FragmentableArray<SleepDataNode>>(
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  summaryDeepCount: () => Promise<Int>;
  summaryDeepMinutes: () => Promise<Int>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<Int>;
  summaryLightCount: () => Promise<Int>;
  summaryLightMinutes: () => Promise<Int>;
  summaryLightThirtyDayAvgMinutes: () => Promise<Int>;
  summaryRemCount: () => Promise<Int>;
  summaryRemMinutes: () => Promise<Int>;
  summaryRemThirtyDayAvgMinutes: () => Promise<Int>;
  summaryWakeCount: () => Promise<Int>;
  summaryWakeMinutes: () => Promise<Int>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<Int>;
  summaryAsleepCount: () => Promise<Int>;
  summaryAsleepMinutes: () => Promise<Int>;
  summaryAwakeCount: () => Promise<Int>;
  summaryAwakeMinutes: () => Promise<Int>;
  summaryRestlessCount: () => Promise<Int>;
  summaryRestlessMinutes: () => Promise<Int>;
}

export interface SleepLogSubscription
  extends Promise<AsyncIterator<SleepLogNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  dateOfSleep: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  efficiency: () => Promise<AsyncIterator<Int>>;
  isMainSleep: () => Promise<AsyncIterator<Boolean>>;
  logId: () => Promise<AsyncIterator<Float>>;
  minutesAfterWakeup: () => Promise<AsyncIterator<Int>>;
  minutesAsleep: () => Promise<AsyncIterator<Int>>;
  minutesAwake: () => Promise<AsyncIterator<Int>>;
  minutesToFallAsleep: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  timeInBed: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  sleepData: <T = Promise<AsyncIterator<SleepDataSubscription>>>(
    args?: {
      where?: SleepDataWhereInput;
      orderBy?: SleepDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  summaryDeepCount: () => Promise<AsyncIterator<Int>>;
  summaryDeepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightCount: () => Promise<AsyncIterator<Int>>;
  summaryLightMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemCount: () => Promise<AsyncIterator<Int>>;
  summaryRemMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeCount: () => Promise<AsyncIterator<Int>>;
  summaryWakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAsleepCount: () => Promise<AsyncIterator<Int>>;
  summaryAsleepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAwakeCount: () => Promise<AsyncIterator<Int>>;
  summaryAwakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRestlessCount: () => Promise<AsyncIterator<Int>>;
  summaryRestlessMinutes: () => Promise<AsyncIterator<Int>>;
}

export interface SleepLogPreviousValuesNode {
  id: ID_Output;
  dateOfSleep: String;
  duration: Int;
  efficiency: Int;
  isMainSleep: Boolean;
  logId: Float;
  minutesAfterWakeup: Int;
  minutesAsleep: Int;
  minutesAwake: Int;
  minutesToFallAsleep: Int;
  startTime: DateTimeOutput;
  timeInBed: Int;
  type?: String;
  summaryDeepCount?: Int;
  summaryDeepMinutes?: Int;
  summaryDeepThirtyDayAvgMinutes?: Int;
  summaryLightCount?: Int;
  summaryLightMinutes?: Int;
  summaryLightThirtyDayAvgMinutes?: Int;
  summaryRemCount?: Int;
  summaryRemMinutes?: Int;
  summaryRemThirtyDayAvgMinutes?: Int;
  summaryWakeCount?: Int;
  summaryWakeMinutes?: Int;
  summaryWakeThirtyDayAvgMinutes?: Int;
  summaryAsleepCount?: Int;
  summaryAsleepMinutes?: Int;
  summaryAwakeCount?: Int;
  summaryAwakeMinutes?: Int;
  summaryRestlessCount?: Int;
  summaryRestlessMinutes?: Int;
}

export interface SleepLogPreviousValues
  extends Promise<SleepLogPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateOfSleep: () => Promise<String>;
  duration: () => Promise<Int>;
  efficiency: () => Promise<Int>;
  isMainSleep: () => Promise<Boolean>;
  logId: () => Promise<Float>;
  minutesAfterWakeup: () => Promise<Int>;
  minutesAsleep: () => Promise<Int>;
  minutesAwake: () => Promise<Int>;
  minutesToFallAsleep: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  timeInBed: () => Promise<Int>;
  type: () => Promise<String>;
  summaryDeepCount: () => Promise<Int>;
  summaryDeepMinutes: () => Promise<Int>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<Int>;
  summaryLightCount: () => Promise<Int>;
  summaryLightMinutes: () => Promise<Int>;
  summaryLightThirtyDayAvgMinutes: () => Promise<Int>;
  summaryRemCount: () => Promise<Int>;
  summaryRemMinutes: () => Promise<Int>;
  summaryRemThirtyDayAvgMinutes: () => Promise<Int>;
  summaryWakeCount: () => Promise<Int>;
  summaryWakeMinutes: () => Promise<Int>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<Int>;
  summaryAsleepCount: () => Promise<Int>;
  summaryAsleepMinutes: () => Promise<Int>;
  summaryAwakeCount: () => Promise<Int>;
  summaryAwakeMinutes: () => Promise<Int>;
  summaryRestlessCount: () => Promise<Int>;
  summaryRestlessMinutes: () => Promise<Int>;
}

export interface SleepLogPreviousValuesSubscription
  extends Promise<AsyncIterator<SleepLogPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateOfSleep: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  efficiency: () => Promise<AsyncIterator<Int>>;
  isMainSleep: () => Promise<AsyncIterator<Boolean>>;
  logId: () => Promise<AsyncIterator<Float>>;
  minutesAfterWakeup: () => Promise<AsyncIterator<Int>>;
  minutesAsleep: () => Promise<AsyncIterator<Int>>;
  minutesAwake: () => Promise<AsyncIterator<Int>>;
  minutesToFallAsleep: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  timeInBed: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  summaryDeepCount: () => Promise<AsyncIterator<Int>>;
  summaryDeepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryDeepThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightCount: () => Promise<AsyncIterator<Int>>;
  summaryLightMinutes: () => Promise<AsyncIterator<Int>>;
  summaryLightThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemCount: () => Promise<AsyncIterator<Int>>;
  summaryRemMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRemThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeCount: () => Promise<AsyncIterator<Int>>;
  summaryWakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryWakeThirtyDayAvgMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAsleepCount: () => Promise<AsyncIterator<Int>>;
  summaryAsleepMinutes: () => Promise<AsyncIterator<Int>>;
  summaryAwakeCount: () => Promise<AsyncIterator<Int>>;
  summaryAwakeMinutes: () => Promise<AsyncIterator<Int>>;
  summaryRestlessCount: () => Promise<AsyncIterator<Int>>;
  summaryRestlessMinutes: () => Promise<AsyncIterator<Int>>;
}

export interface SleepLogSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SleepLogSubscriptionPayload
  extends Promise<SleepLogSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SleepLog>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SleepLogPreviousValues>() => T;
}

export interface SleepLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SleepLogSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SleepLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SleepLogPreviousValuesSubscription>() => T;
}

export interface AggregateHeartLogNode {
  count: Int;
}

export interface AggregateHeartLog
  extends Promise<AggregateHeartLogNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeartLogSubscription
  extends Promise<AsyncIterator<AggregateHeartLogNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateStepDataNode {
  count: Int;
}

export interface AggregateStepData
  extends Promise<AggregateStepDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepDataSubscription
  extends Promise<AsyncIterator<AggregateStepDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DistanceLogConnectionNode {}

export interface DistanceLogConnection
  extends Promise<DistanceLogConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DistanceLogEdgeNode>>() => T;
  aggregate: <T = AggregateDistanceLog>() => T;
}

export interface DistanceLogConnectionSubscription
  extends Promise<AsyncIterator<DistanceLogConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DistanceLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDistanceLogSubscription>() => T;
}

export interface GoogleFitAccountConnectionNode {}

export interface GoogleFitAccountConnection
  extends Promise<GoogleFitAccountConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<GoogleFitAccountEdgeNode>>() => T;
  aggregate: <T = AggregateGoogleFitAccount>() => T;
}

export interface GoogleFitAccountConnectionSubscription
  extends Promise<AsyncIterator<GoogleFitAccountConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GoogleFitAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGoogleFitAccountSubscription>() => T;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
